{"id":"morphir-rust-72s","title":"Implement Python binding using Ruff parser crate","description":"Create a morphir-python-binding crate that uses Ruff's parser and AST crates to parse Python source code and convert it to Morphir IR.\n\n## Background\n\nRuff is a fast Python linter and formatter written in Rust. It provides high-quality parser and AST crates that can be reused:\n- `ruff_python_parser` - Python parser\n- `ruff_python_ast` - Python AST types\n\n## Goals\n\n1. Create `morphir-python-binding` crate following the same pattern as `morphir-gleam-binding`\n2. Use Ruff's parser crate for parsing Python source files\n3. Transform Ruff's Python AST to Morphir IR\n4. Support Python type hints for type information extraction\n5. Enable roundtrip testing (Python → IR → Python)\n\n## Benefits\n\n- **Performance**: Ruff's parser is highly optimized Rust code\n- **Correctness**: Well-tested parser used in production by the Ruff project\n- **Compatibility**: Supports modern Python syntax (3.7+)\n- **Maintenance**: Parser updates come from active Ruff development\n\n## Implementation Steps\n\n1. Add ruff_python_parser and ruff_python_ast as dependencies\n2. Create Python AST to ModuleIR visitor\n3. Implement type annotation parsing for function signatures\n4. Add BDD acceptance tests with Python fixtures\n5. Support Python project parsing (multiple modules)\n\n## References\n\n- Ruff GitHub: https://github.com/astral-sh/ruff\n- ruff_python_parser crate: https://crates.io/crates/ruff_python_parser\n- ruff_python_ast crate: https://crates.io/crates/ruff_python_ast","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-24T11:35:28.092178725-06:00","created_by":"damian","updated_at":"2026-01-24T11:35:39.738018531-06:00"}
{"id":"morphir-rust-kw8","title":"Design and implement Morphir daemon and extension system","description":"Design and implement a complete Morphir daemon and extension system, enabling long-running services, IDE integration, and pluggable language/backend support.\n\n## Vision\n\nCreate a daemon-based architecture that:\n1. Provides fast, incremental compilation through persistent state\n2. Enables IDE extensions (VS Code, IntelliJ, etc.) via LSP\n3. Supports pluggable frontends (language bindings) and backends (code generators)\n4. Offers real-time validation and type checking\n\n---\n\n## Phase 1: MVP Daemon (P1)\n\n### Goals\n- Basic daemon process that stays running\n- Unix socket or TCP communication\n- Simple request/response protocol (JSON-RPC or custom)\n- File watching for automatic recompilation\n\n### Deliverables\n- `morphir-daemon` crate with basic lifecycle management\n- `morphir daemon start/stop/status` CLI commands\n- Simple compile request handling\n- Basic health check endpoint\n\n### Architecture\n```\n┌─────────────┐     ┌─────────────────┐\n│  CLI/IDE    │────▶│  Morphir Daemon │\n└─────────────┘     │  ┌───────────┐  │\n                    │  │  Compiler │  │\n                    │  └───────────┘  │\n                    │  ┌───────────┐  │\n                    │  │  Cache    │  │\n                    │  └───────────┘  │\n                    └─────────────────┘\n```\n\n---\n\n## Phase 2: Extension System Design (P1)\n\n### Goals\n- Define extension API and plugin interface\n- Support dynamic loading of language bindings\n- Support dynamic loading of code generators\n- Configuration-driven extension discovery\n\n### Extension Types\n1. **Frontend Extensions** (Language Bindings)\n   - Parse source language → Morphir IR\n   - Examples: Gleam, Python, TypeScript, Elm\n\n2. **Backend Extensions** (Code Generators)\n   - Morphir IR → Target language/platform\n   - Examples: Spark, Flink, SQL, JavaScript\n\n3. **Analyzer Extensions**\n   - Custom validation rules\n   - Type inference plugins\n   - Documentation generators\n\n### Plugin Interface\n```rust\npub trait FrontendExtension {\n    fn name(\u0026self) -\u003e \u0026str;\n    fn file_extensions(\u0026self) -\u003e \u0026[\u0026str];\n    fn parse(\u0026self, source: \u0026str) -\u003e Result\u003cModuleIR\u003e;\n}\n\npub trait BackendExtension {\n    fn name(\u0026self) -\u003e \u0026str;\n    fn generate(\u0026self, ir: \u0026Distribution) -\u003e Result\u003cGeneratedOutput\u003e;\n}\n```\n\n---\n\n## Phase 3: LSP Implementation (P2)\n\n### Goals\n- Language Server Protocol implementation\n- Real-time diagnostics and error reporting\n- Go-to-definition, find references\n- Hover information with type details\n- Code completion suggestions\n\n### Deliverables\n- `morphir-lsp` crate\n- VS Code extension package\n- Support for multiple source languages\n\n---\n\n## Phase 4: Production Hardening (P2)\n\n### Goals\n- Robust error handling and recovery\n- Graceful shutdown and restart\n- Logging and observability (tracing, metrics)\n- Resource limits and throttling\n- Multi-project workspace support\n\n### Deliverables\n- Structured logging with tracing\n- Prometheus metrics endpoint\n- Watchdog and auto-restart\n- Connection pooling and request queuing\n\n---\n\n## Phase 5: IDE Extensions (P3)\n\n### Goals\n- VS Code extension with full feature set\n- IntelliJ plugin\n- Neovim/Vim LSP configuration\n- Emacs support\n\n### Features\n- Syntax highlighting\n- Inline error display\n- Code actions and quick fixes\n- Morphir IR visualization\n- Type hierarchy explorer\n\n---\n\n## Implementation Approach\n\n### Incremental Delivery\n1. Start with MVP daemon (file watch + compile)\n2. Add extension loading mechanism\n3. Implement LSP basics (diagnostics)\n4. Expand LSP features iteratively\n5. Build IDE extensions on stable LSP\n\n### Technology Choices\n- **IPC**: Unix sockets (local), TCP (remote)\n- **Protocol**: JSON-RPC 2.0 (LSP compatible)\n- **Plugin Loading**: Dynamic libraries or WASM\n- **File Watching**: notify crate\n\n---\n\n## Success Criteria\n\n### MVP\n- [ ] Daemon starts and accepts connections\n- [ ] File changes trigger recompilation\n- [ ] Compilation results returned to client\n- [ ] Clean shutdown on signal\n\n### Extension System\n- [ ] Extensions discovered from config\n- [ ] Dynamic loading works\n- [ ] Multiple frontends can coexist\n- [ ] Multiple backends can coexist\n\n### LSP\n- [ ] Diagnostics appear in VS Code\n- [ ] Go-to-definition works\n- [ ] Type information on hover\n- [ ] Extension published to marketplace\n\n---\n\n## Related Issues\n- morphir-cet: Switch to official Gleam parser (frontend extension)\n- morphir-rust-72s: Python binding using Ruff (frontend extension)\n- morphir-rust-ykr: TypeScript binding using SWC (frontend extension)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-24T11:37:29.981402829-06:00","created_by":"damian","updated_at":"2026-01-24T11:37:55.123239594-06:00"}
{"id":"morphir-rust-y0l","title":"Fix failing Gleam binding acceptance tests","description":"Several Gleam binding acceptance tests are failing and have been marked as @wip (work in progress):\n\n## Failing Tests\n\n### 1. Roundtrip Tests (roundtrip.feature)\n- **order_validation** scenario - Parser fails on generated function signatures with tupled arguments\n- **order_processing** scenario - Same parser issue with function signatures\n\n### 2. CLI Integration Tests (cli.feature)\n- All CLI tests - Require full CLI functionality to be implemented\n\n### 3. Project Parsing Tests (project.feature)\n- Module name lookup uses full path instead of module name (e.g., looking for 'main' but stored as 'src/main')\n\n### 4. Workspace Tests (workspace.feature)\n- Workspace parsing not yet implemented\n\n### 5. Code Generation Tests (codegen.feature)\n- Code generation steps not yet implemented\n\n## Root Causes\n\n1. **Roundtrip failures**: The Gleam parser generates function signatures with tupled parameters like `fn(#(a, b))` but cannot parse them back. The signature should be `fn(a, b)` or handle tupled parameters correctly.\n\n2. **Project parsing**: Module names need to be derived from the file path relative to src/, not include the full path or 'src/' prefix.\n\n3. **CLI/Workspace/Codegen**: These features are not yet implemented.\n\n## Impact\nBlocking full roundtrip testing for complex business logic fixtures.","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-24T11:30:03.083133986-06:00","created_by":"damian","updated_at":"2026-01-24T11:30:13.91608221-06:00"}
{"id":"morphir-rust-ykr","title":"Implement TypeScript binding using SWC parser crate","description":"Create a morphir-typescript-binding crate that uses SWC's parser and AST crates to parse TypeScript source code and convert it to Morphir IR.\n\n## Background\n\nSWC (Speedy Web Compiler) is a fast TypeScript/JavaScript compiler written in Rust. It provides production-quality parser and AST crates:\n- `swc_ecma_parser` - ECMAScript/TypeScript parser\n- `swc_ecma_ast` - ECMAScript/TypeScript AST types\n\n## Goals\n\n1. Create `morphir-typescript-binding` crate following the same pattern as `morphir-gleam-binding`\n2. Use SWC's parser crate for parsing TypeScript source files\n3. Transform SWC's TypeScript AST to Morphir IR\n4. Leverage TypeScript's type annotations for rich type information\n5. Enable roundtrip testing (TypeScript → IR → TypeScript)\n\n## Benefits\n\n- **Performance**: SWC is one of the fastest TS/JS parsers available\n- **Correctness**: Battle-tested parser used by Next.js, Deno, and other major projects\n- **Compatibility**: Full TypeScript syntax support including latest features\n- **Maintenance**: Active development with regular releases\n\n## Implementation Steps\n\n1. Add swc_ecma_parser and swc_ecma_ast as dependencies\n2. Create TypeScript AST to ModuleIR visitor\n3. Handle TypeScript-specific constructs (interfaces, type aliases, generics)\n4. Support both .ts and .tsx files\n5. Add BDD acceptance tests with TypeScript fixtures\n6. Support TypeScript project parsing (tsconfig.json awareness)\n\n## TypeScript Features to Support\n\n- Function declarations with type annotations\n- Interface and type alias definitions\n- Class definitions\n- Module imports/exports\n- Generic types\n- Union and intersection types\n\n## References\n\n- SWC GitHub: https://github.com/swc-project/swc\n- swc_ecma_parser crate: https://crates.io/crates/swc_ecma_parser\n- swc_ecma_ast crate: https://crates.io/crates/swc_ecma_ast","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-24T11:36:03.013293463-06:00","created_by":"damian","updated_at":"2026-01-24T11:36:13.181742356-06:00"}
