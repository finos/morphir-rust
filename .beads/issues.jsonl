{"id":"morphir-rust-72s","title":"Implement Python binding using Ruff parser crate","description":"Create a morphir-python-binding crate that uses Ruff's parser and AST crates to parse Python source code and convert it to Morphir IR.\n\n## Background\n\nRuff is a fast Python linter and formatter written in Rust. It provides high-quality parser and AST crates that can be reused:\n- `ruff_python_parser` - Python parser\n- `ruff_python_ast` - Python AST types\n\n## Goals\n\n1. Create `morphir-python-binding` crate following the same pattern as `morphir-gleam-binding`\n2. Use Ruff's parser crate for parsing Python source files\n3. Transform Ruff's Python AST to Morphir IR\n4. Support Python type hints for type information extraction\n5. Enable roundtrip testing (Python → IR → Python)\n\n## Benefits\n\n- **Performance**: Ruff's parser is highly optimized Rust code\n- **Correctness**: Well-tested parser used in production by the Ruff project\n- **Compatibility**: Supports modern Python syntax (3.7+)\n- **Maintenance**: Parser updates come from active Ruff development\n\n## Implementation Steps\n\n1. Add ruff_python_parser and ruff_python_ast as dependencies\n2. Create Python AST to ModuleIR visitor\n3. Implement type annotation parsing for function signatures\n4. Add BDD acceptance tests with Python fixtures\n5. Support Python project parsing (multiple modules)\n\n## References\n\n- Ruff GitHub: https://github.com/astral-sh/ruff\n- ruff_python_parser crate: https://crates.io/crates/ruff_python_parser\n- ruff_python_ast crate: https://crates.io/crates/ruff_python_ast","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-24T11:35:28.092178725-06:00","created_by":"damian","updated_at":"2026-01-24T11:35:39.738018531-06:00"}
{"id":"morphir-rust-kw8","title":"Design and implement Morphir daemon and extension system","description":"Design and implement a complete Morphir daemon and extension system, enabling long-running services, IDE integration, and pluggable language/backend support.\n\n## Vision\n\nCreate a daemon-based architecture that:\n1. Provides fast, incremental compilation through persistent state\n2. Enables IDE extensions (VS Code, IntelliJ, etc.) via LSP\n3. Supports pluggable frontends (language bindings) and backends (code generators)\n4. Offers real-time validation and type checking\n\n---\n\n## Phase 1: MVP Daemon (P1)\n\n### Goals\n- Basic daemon process that stays running\n- Unix socket or TCP communication\n- Simple request/response protocol (JSON-RPC or custom)\n- File watching for automatic recompilation\n\n### Deliverables\n- `morphir-daemon` crate with basic lifecycle management\n- `morphir daemon start/stop/status` CLI commands\n- Simple compile request handling\n- Basic health check endpoint\n\n### Architecture\n```\n┌─────────────┐     ┌─────────────────┐\n│  CLI/IDE    │────▶│  Morphir Daemon │\n└─────────────┘     │  ┌───────────┐  │\n                    │  │  Compiler │  │\n                    │  └───────────┘  │\n                    │  ┌───────────┐  │\n                    │  │  Cache    │  │\n                    │  └───────────┘  │\n                    └─────────────────┘\n```\n\n---\n\n## Phase 2: Extension System Design (P1)\n\n### Goals\n- Define extension API and plugin interface\n- Support dynamic loading of language bindings\n- Support dynamic loading of code generators\n- Configuration-driven extension discovery\n\n### Extension Types\n1. **Frontend Extensions** (Language Bindings)\n   - Parse source language → Morphir IR\n   - Examples: Gleam, Python, TypeScript, Elm\n\n2. **Backend Extensions** (Code Generators)\n   - Morphir IR → Target language/platform\n   - Examples: Spark, Flink, SQL, JavaScript\n\n3. **Analyzer Extensions**\n   - Custom validation rules\n   - Type inference plugins\n   - Documentation generators\n\n### Plugin Interface\n```rust\npub trait FrontendExtension {\n    fn name(&self) -> &str;\n    fn file_extensions(&self) -> &[&str];\n    fn parse(&self, source: &str) -> Result<ModuleIR>;\n}\n\npub trait BackendExtension {\n    fn name(&self) -> &str;\n    fn generate(&self, ir: &Distribution) -> Result<GeneratedOutput>;\n}\n```\n\n---\n\n## Phase 3: LSP Implementation (P2)\n\n### Goals\n- Language Server Protocol implementation\n- Real-time diagnostics and error reporting\n- Go-to-definition, find references\n- Hover information with type details\n- Code completion suggestions\n\n### Deliverables\n- `morphir-lsp` crate\n- VS Code extension package\n- Support for multiple source languages\n\n---\n\n## Phase 4: Production Hardening (P2)\n\n### Goals\n- Robust error handling and recovery\n- Graceful shutdown and restart\n- Logging and observability (tracing, metrics)\n- Resource limits and throttling\n- Multi-project workspace support\n\n### Deliverables\n- Structured logging with tracing\n- Prometheus metrics endpoint\n- Watchdog and auto-restart\n- Connection pooling and request queuing\n\n---\n\n## Phase 5: IDE Extensions (P3)\n\n### Goals\n- VS Code extension with full feature set\n- IntelliJ plugin\n- Neovim/Vim LSP configuration\n- Emacs support\n\n### Features\n- Syntax highlighting\n- Inline error display\n- Code actions and quick fixes\n- Morphir IR visualization\n- Type hierarchy explorer\n\n---\n\n## Implementation Approach\n\n### Incremental Delivery\n1. Start with MVP daemon (file watch + compile)\n2. Add extension loading mechanism\n3. Implement LSP basics (diagnostics)\n4. Expand LSP features iteratively\n5. Build IDE extensions on stable LSP\n\n### Technology Choices\n- **IPC**: Unix sockets (local), TCP (remote)\n- **Protocol**: JSON-RPC 2.0 (LSP compatible)\n- **Plugin Loading**: Dynamic libraries or WASM\n- **File Watching**: notify crate\n\n---\n\n## Success Criteria\n\n### MVP\n- [ ] Daemon starts and accepts connections\n- [ ] File changes trigger recompilation\n- [ ] Compilation results returned to client\n- [ ] Clean shutdown on signal\n\n### Extension System\n- [ ] Extensions discovered from config\n- [ ] Dynamic loading works\n- [ ] Multiple frontends can coexist\n- [ ] Multiple backends can coexist\n\n### LSP\n- [ ] Diagnostics appear in VS Code\n- [ ] Go-to-definition works\n- [ ] Type information on hover\n- [ ] Extension published to marketplace\n\n---\n\n## Related Issues\n- morphir-cet: Switch to official Gleam parser (frontend extension)\n- morphir-rust-72s: Python binding using Ruff (frontend extension)\n- morphir-rust-ykr: TypeScript binding using SWC (frontend extension)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-24T11:37:29.981402829-06:00","created_by":"damian","updated_at":"2026-01-24T11:37:55.123239594-06:00"}
{"id":"morphir-rust-y0l","title":"Fix failing Gleam binding acceptance tests","description":"Several Gleam binding acceptance tests are failing and have been marked as @wip (work in progress):\n\n## Failing Tests\n\n### 1. Roundtrip Tests (roundtrip.feature)\n- **order_validation** scenario - Parser fails on generated function signatures with tupled arguments\n- **order_processing** scenario - Same parser issue with function signatures\n\n### 2. CLI Integration Tests (cli.feature)\n- All CLI tests - Require full CLI functionality to be implemented\n\n### 3. Project Parsing Tests (project.feature)\n- Module name lookup uses full path instead of module name (e.g., looking for 'main' but stored as 'src/main')\n\n### 4. Workspace Tests (workspace.feature)\n- Workspace parsing not yet implemented\n\n### 5. Code Generation Tests (codegen.feature)\n- Code generation steps not yet implemented\n\n## Root Causes\n\n1. **Roundtrip failures**: The Gleam parser generates function signatures with tupled parameters like `fn(#(a, b))` but cannot parse them back. The signature should be `fn(a, b)` or handle tupled parameters correctly.\n\n2. **Project parsing**: Module names need to be derived from the file path relative to src/, not include the full path or 'src/' prefix.\n\n3. **CLI/Workspace/Codegen**: These features are not yet implemented.\n\n## Impact\nBlocking full roundtrip testing for complex business logic fixtures.","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-24T11:30:03.083133986-06:00","created_by":"damian","updated_at":"2026-01-24T11:30:13.91608221-06:00"}
{"id":"morphir-rust-ykr","title":"Implement TypeScript binding using SWC parser crate","description":"Create a morphir-typescript-binding crate that uses SWC's parser and AST crates to parse TypeScript source code and convert it to Morphir IR.\n\n## Background\n\nSWC (Speedy Web Compiler) is a fast TypeScript/JavaScript compiler written in Rust. It provides production-quality parser and AST crates:\n- `swc_ecma_parser` - ECMAScript/TypeScript parser\n- `swc_ecma_ast` - ECMAScript/TypeScript AST types\n\n## Goals\n\n1. Create `morphir-typescript-binding` crate following the same pattern as `morphir-gleam-binding`\n2. Use SWC's parser crate for parsing TypeScript source files\n3. Transform SWC's TypeScript AST to Morphir IR\n4. Leverage TypeScript's type annotations for rich type information\n5. Enable roundtrip testing (TypeScript → IR → TypeScript)\n\n## Benefits\n\n- **Performance**: SWC is one of the fastest TS/JS parsers available\n- **Correctness**: Battle-tested parser used by Next.js, Deno, and other major projects\n- **Compatibility**: Full TypeScript syntax support including latest features\n- **Maintenance**: Active development with regular releases\n\n## Implementation Steps\n\n1. Add swc_ecma_parser and swc_ecma_ast as dependencies\n2. Create TypeScript AST to ModuleIR visitor\n3. Handle TypeScript-specific constructs (interfaces, type aliases, generics)\n4. Support both .ts and .tsx files\n5. Add BDD acceptance tests with TypeScript fixtures\n6. Support TypeScript project parsing (tsconfig.json awareness)\n\n## TypeScript Features to Support\n\n- Function declarations with type annotations\n- Interface and type alias definitions\n- Class definitions\n- Module imports/exports\n- Generic types\n- Union and intersection types\n\n## References\n\n- SWC GitHub: https://github.com/swc-project/swc\n- swc_ecma_parser crate: https://crates.io/crates/swc_ecma_parser\n- swc_ecma_ast crate: https://crates.io/crates/swc_ecma_ast","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-24T11:36:03.013293463-06:00","created_by":"damian","updated_at":"2026-01-24T11:36:13.181742356-06:00"}
{"id":"morphir-rust-dt1","title":"Implement design-time extension runtime","description":"Implement the runtime interface for design-time extensions (frontend, backend, common-backend) using the process() pattern.\n\n## Background\nDesign-time extensions transform Morphir IR or source code. They use a simpler call pattern than runtime extensions: process(input) -> output.\n\n## Tasks\n- [ ] Implement DesignTimeExtension trait with process() method\n- [ ] Add support for frontend-compile(input: Envelope) -> Envelope\n- [ ] Add support for backend-generate(input: Envelope) -> Envelope\n- [ ] Add support for get-capabilities() -> Envelope\n- [ ] Implement extension registry for discovery\n- [ ] Add configuration-driven extension loading\n- [ ] Handle design-time specific host functions (workspace, ir_helpers)\n\n## Acceptance Criteria\n- DesignTimeExtension can load and call frontend extensions\n- DesignTimeExtension can load and call backend extensions\n- Extension registry discovers extensions from config\n- Capabilities querying works correctly\n- Design-time host functions are available to extensions\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md (lines 383-508)\n\n## Related Issues\n- Depends on: morphir-rust-ext1\n- Part of WASM extension architecture (see morphir-rust-kw8)","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-29T10:38:09.176382600-06:00","created_by":"damian","updated_at":"2026-01-29T10:38:09.176382600-06:00"}
{"id":"morphir-rust-kam1","title":"Implement Kameo actor wrapper for extensions","description":"Wrap the Morphir runtime in Kameo actors to provide isolation, concurrency, and lifecycle management for extension execution.\n\n## Background\nEach extension operation runs inside a Kameo actor that owns runtime state, loaded programs, workspace/session state, and manages the TEA loop or process() calls.\n\n## Tasks\n- [ ] Create ExtensionActor struct using Kameo\n- [ ] Implement actor lifecycle (spawn, stop, restart)\n- [ ] Add workspace and session state management\n- [ ] Implement message protocol between daemon and actors\n- [ ] Add support for loading multiple extensions per actor\n- [ ] Implement TEA loop execution within actor\n- [ ] Implement design-time process() execution within actor\n- [ ] Add async host function support\n- [ ] Stream progress and results back to daemon\n\n## Acceptance Criteria\n- ExtensionActor successfully wraps Morphir runtime\n- Actor can load and execute TEA runtime extensions\n- Actor can load and execute design-time extensions\n- Workspace/session state is maintained correctly\n- Message protocol handles requests/responses properly\n- Actors provide isolation between extension instances\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md (lines 627-686)\n\n## Related Issues\n- Depends on: morphir-rust-tea1, morphir-rust-dt1\n- Part of WASM extension architecture (see morphir-rust-kw8)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-29T10:38:09.176382600-06:00","created_by":"damian","updated_at":"2026-01-29T10:38:09.176382600-06:00"}
{"id":"morphir-rust-std1","title":"Implement standard library host functions","description":"Implement the standard library of host functions that extensions can call via the Morphir runtime.\n\n## Background\nExtensions need access to host capabilities like logging, environment variables, HTTP, filesystem, and Morphir IR helpers. These are exposed as host functions registered with the WASM runtime.\n\n## Tasks\n- [ ] Implement log(level, msg) host function\n- [ ] Implement get_env_var(name) host function\n- [ ] Implement set_env_var(name, value) host function\n- [ ] Implement random() host function\n- [ ] Implement http(request) host function for HTTP calls\n- [ ] Implement workspace(operation) for design-time workspace access\n- [ ] Implement ir_helpers() for common IR operations\n- [ ] Register all host functions with Extism\n- [ ] Create language-specific SDK bindings (Rust, TypeScript, etc.)\n- [ ] Document standard library API\n\n## Acceptance Criteria\n- All host functions work when called from WASM extensions\n- Host functions use Envelope protocol consistently\n- Error handling is robust and informative\n- SDK bindings provide ergonomic APIs for extension authors\n- Standard library is documented with examples\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md (lines 589-625)\n\n## Related Issues\n- Depends on: morphir-rust-ext1\n- Part of WASM extension architecture (see morphir-rust-kw8)","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-29T10:38:09.176382600-06:00","created_by":"damian","updated_at":"2026-01-29T10:38:09.176382600-06:00"}
{"id":"morphir-rust-wit1","title":"Define WIT interfaces for Component Model support","description":"Define WebAssembly Interface Types (WIT) for the extension ABI to support WebAssembly Component Model in addition to core WASM.\n\n## Background\nThe Component Model provides a more structured and type-safe way to build WASM modules. Defining WIT interfaces enables extensions to use wit-bindgen and provides better interoperability.\n\n## Tasks\n- [ ] Define envelope.wit with Header and Envelope types\n- [ ] Define runtime.wit with host function imports\n- [ ] Define program.wit with TEA extension exports (init/update/subscriptions)\n- [ ] Define design-time.wit with frontend/backend extension exports\n- [ ] Create Component Model wrappers for Wasmtime\n- [ ] Create Component Model wrappers for jco (browser)\n- [ ] Test Component Model extensions alongside core WASM extensions\n- [ ] Document Component Model build process for extension authors\n\n## Acceptance Criteria\n- WIT definitions compile and generate correct bindings\n- Extensions can be built using wit-bindgen\n- Component Model extensions work with core WASM runtime\n- Browser support via jco is functional\n- Documentation guides extension authors through Component Model usage\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md (lines 393-508)\n\n## Related Issues\n- Depends on: morphir-rust-env1\n- Part of WASM extension architecture (see morphir-rust-kw8)\n- Optional/future enhancement (P3)","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-29T10:38:09.176382600-06:00","created_by":"damian","updated_at":"2026-01-29T10:38:09.176382600-06:00"}
{"id":"morphir-rust-env1","title":"Implement Envelope protocol layer for extension ABI","description":"Implement the Envelope + JSON codec (host side) as the foundation for the unified extension model.\n\n## PREREQUISITE: Gherkin Acceptance Tests Required\n\n**BEFORE IMPLEMENTATION**: Prepare comprehensive Gherkin acceptance tests and present to user for approval. Implementation may NOT proceed without user verification of tests.\n\nTests must cover:\n- Envelope creation from various Serialize types\n- JSON encoding/decoding roundtrips\n- Header field initialization and handling\n- Content type validation\n- Error cases (invalid JSON, type mismatches, etc.)\n- Edge cases (empty content, large payloads, etc.)\n\n## Background\nThe WASM extension architecture uses an envelope-based protocol that is host-agnostic and works across CLI, daemon, services, and browser hosts.\n\n## Tasks\n- [ ] **FIRST: Create Gherkin acceptance tests and get user approval**\n- [ ] Implement Envelope struct with Header, content_type, and content fields\n- [ ] Implement JSON codec for Envelope serialization/deserialization\n- [ ] Define JSON payload conventions for TEA runtime (init/update/subscriptions)\n- [ ] Define JSON payload conventions for design-time extensions\n- [ ] Add helper methods (json(), as_json()) for common operations\n- [ ] Document envelope content_type conventions\n\n## Acceptance Criteria\n- **Gherkin tests approved by user before implementation**\n- All Gherkin scenarios pass\n- Envelope can be created from any Serialize type\n- Envelope content can be deserialized to any Deserialize type\n- Header includes seqnum, session_id, and optional kind\n- JSON encoding/decoding roundtrips correctly\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md\n- ~/AGENTS.md - Gherkin Acceptance Test Requirement\n\n## Related Issues\n- Part of WASM extension architecture (see morphir-rust-kw8)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-29T10:29:50.370720-06:00","created_by":"damian","updated_at":"2026-01-29T10:42:47.396323900-06:00"}
{"id":"morphir-rust-ext1","title":"Implement Extism runtime integration wrapper","description":"**Location**: morphir-ext/src/extism_runtime.rs\n\nWrap Extism as a hidden implementation detail and provide an envelope-based API for loading and calling WASM extension programs.\n\n## PREREQUISITE: Gherkin Acceptance Tests Required\n\n**BEFORE IMPLEMENTATION**: Prepare comprehensive Gherkin acceptance tests and present to user for approval. Implementation may NOT proceed without user verification of tests.\n\nTests must cover:\n- ExtismRuntime construction with various WASM module formats\n- call_envelope() with different envelope types\n- Envelope encoding/decoding during WASM calls\n- Error handling (invalid WASM, missing functions, runtime errors)\n- Memory management and cleanup\n- No Extism types in public API\n\n## Background\nExtism is used internally to load and execute WASM modules, but must remain hidden from extension authors. The runtime provides a clean envelope-based API that works with any WASM engine.\n\n## Tasks\n- [ ] **FIRST: Create Gherkin acceptance tests and get user approval**\n- [ ] Implement ExtismRuntime wrapper struct\n- [ ] Add new() method to load WASM bytes via Extism Manifest\n- [ ] Implement call_envelope() method that takes/returns Envelope\n- [ ] Convert between Envelope and raw bytes for Extism calls\n- [ ] Handle Extism errors and map to Morphir error types\n- [ ] Ensure no Extism types leak into public API\n\n## Acceptance Criteria\n- **Gherkin tests approved by user before implementation**\n- All Gherkin scenarios pass\n- ExtismRuntime can load core WASM modules\n- call_envelope() successfully invokes WASM functions\n- Envelope encoding/decoding works transparently\n- Error handling is robust and informative\n- Extension authors never see Extism types\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md (lines 354-381)\n- ~/AGENTS.md - Gherkin Acceptance Test Requirement\n\n## Related Issues\n- Depends on: morphir-rust-env1\n- Part of WASM extension architecture (see morphir-rust-kw8)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-29T10:36:48.172597100-06:00","created_by":"damian","updated_at":"2026-01-29T10:43:21.515465100-06:00"}
{"id":"morphir-rust-tea1","title":"Implement TEA runtime for runtime extensions","description":"Implement The Elm Architecture (TEA) runtime engine for runtime extensions with init/update/subscriptions semantics.\n\n## PREREQUISITE: Gherkin Acceptance Tests Required\n\n**BEFORE IMPLEMENTATION**: Prepare comprehensive Gherkin acceptance tests and present to user for approval. Implementation may NOT proceed without user verification of tests.\n\nTests must cover:\n- MorphirProgram construction and initialization\n- init() call with various flags, model + cmds parsing\n- update() with different message types, state transitions\n- subscriptions() lifecycle and event stream handling\n- Command interpretation and execution\n- Subscription manager operation\n- State management across multiple update cycles\n- Error cases (invalid model, malformed commands, etc.)\n\n## Background\nRuntime extensions follow TEA-style architecture: pure functions (init/update/subscriptions) that return model and commands, with the runtime managing state and interpreting effects.\n\n## Tasks\n- [ ] **FIRST: Create Gherkin acceptance tests and get user approval**\n- [ ] Implement MorphirProgram struct wrapping ExtismRuntime\n- [ ] Implement init() method: calls extension init, parses model + cmds\n- [ ] Implement update() method: combines msg + model, calls extension, parses output\n- [ ] Implement subscriptions() method: calls extension with model\n- [ ] Add start/send/poll API for host to interact with runtime\n- [ ] Implement command interpreter (cmds envelope -> host function calls)\n- [ ] Implement subscription manager (subs envelope -> event streams)\n- [ ] Add per-program state management\n\n## Acceptance Criteria\n- **Gherkin tests approved by user before implementation**\n- All Gherkin scenarios pass\n- MorphirProgram successfully calls init() and maintains model state\n- update() correctly processes messages and returns new model + commands\n- subscriptions() returns subscription specifications\n- Commands are interpreted and executed via host functions\n- Runtime exposes clean start/send/poll API to host\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md (lines 239-280, 511-588)\n- ~/AGENTS.md - Gherkin Acceptance Test Requirement\n\n## Related Issues\n- Depends on: morphir-rust-ext1\n- Part of WASM extension architecture (see morphir-rust-kw8)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-29T10:37:18.942918-06:00","created_by":"damian","updated_at":"2026-01-29T10:43:21.515465100-06:00"}
{"id":"morphir-rust-direct1","title":"Implement DirectRuntime for browser/WASM mode","description":"Implement DirectRuntime in morphir-ext for direct execution without actors or IPC, targeting browser and WASM client modes.\n\n## Background\nThe morphir-ext crate provides ExtensionRuntime trait as the abstraction. We need a DirectRuntime implementation for environments where daemon/actor infrastructure is not available (browser, standalone WASM).\n\n## Tasks\n- [ ] Create morphir-ext/src/direct.rs module\n- [ ] Implement DirectRuntime struct wrapping ExtensionInstance\n- [ ] Provide simple API for browser/WASM environments\n- [ ] No IPC, no actors - just direct function calls\n- [ ] Support both TEA (init/update/subscriptions) and design-time (process) patterns\n- [ ] Add tests for direct execution mode\n\n## Acceptance Criteria\n- DirectRuntime works in browser WASM context\n- Can instantiate extensions without daemon\n- TEA lifecycle (init/update/subscriptions) works correctly\n- Design-time operations (frontend-compile, backend-generate) work\n- No Kameo or daemon dependencies\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md\n- morphir-ext/src/runtime.rs (ExtensionRuntime trait)\n- morphir-ext/src/actor.rs (actor-based example)\n\n## Related Issues\n- Depends on: morphir-rust-ext1 (ExtismRuntime)\n- Part of WASM extension architecture (see morphir-rust-kw8)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-29T12:00:00-06:00","created_by":"damian","updated_at":"2026-01-29T12:00:00-06:00"}
{"id":"morphir-rust-daemon-client1","title":"Implement DaemonClient for IPC to daemon actors","description":"Implement DaemonClient in morphir-ext that implements ExtensionRuntime trait and communicates with the daemon via IPC.\n\n## Background\nCLI and IDE clients need to communicate with the daemon service which hosts extension actors. DaemonClient provides the client-side implementation of ExtensionRuntime that delegates to remote actors via IPC.\n\n## Tasks\n- [ ] Create morphir-ext/src/daemon_client.rs module\n- [ ] Implement DaemonClient struct\n- [ ] Implement ExtensionRuntime trait for DaemonClient\n- [ ] Add IPC transport layer (JSON-RPC over Unix socket/TCP)\n- [ ] Handle async communication with daemon actors\n- [ ] Support connection pooling and reconnection\n- [ ] Add proper error handling for network failures\n- [ ] Support both TEA and design-time extension calls\n\n## Acceptance Criteria\n- DaemonClient implements ExtensionRuntime trait\n- Can connect to daemon via Unix socket (local) or TCP (remote)\n- All extension calls (init/update/subscriptions) work via IPC\n- Design-time calls (frontend-compile, backend-generate) work via IPC\n- Proper error handling and reconnection logic\n- Connection pooling for multiple concurrent requests\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md\n- morphir-ext/src/runtime.rs (ExtensionRuntime trait)\n- morphir-daemon (daemon service infrastructure)\n\n## Related Issues\n- Depends on: morphir-rust-kam1 (actor infrastructure)\n- Part of WASM extension architecture (see morphir-rust-kw8)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-29T12:00:00-06:00","created_by":"damian","updated_at":"2026-01-29T12:00:00-06:00"}
{"id":"morphir-rust-steel-thread","title":"Steel Thread: Implement migrate command using extension architecture","description":"Build a working end-to-end slice of functionality using the migrate command as a proof-of-concept for the WASM extension architecture.\n\n## Goal\nDemonstrate the extension architecture with a real, working command: `morphir migrate` that transforms Morphir IR from v3 to v4 using a WASM extension.\n\n## Why Migrate Command?\n- **Design-time operation**: IR → IR transform (backend pattern)\n- **Self-contained**: No runtime execution, no complex state\n- **Real-world use case**: Actual production requirement\n- **Tests full stack**: Extension loading, envelope protocol, DirectRuntime, WASM execution\n\n## Architecture Flow\n```\nCLI --> DirectRuntime --> ExtismRuntime --> migrate.wasm\n        (morphir-ext)     (morphir-ext)     (extension)\n```\n\n## Implementation Steps\n\n### 1. Minimal ExtismRuntime (morphir-rust-ext1)\n- [ ] Create morphir-ext/src/extism_runtime.rs\n- [ ] Implement ExtismRuntime struct\n- [ ] Implement call_envelope() method only\n- [ ] Load WASM via Extism Manifest\n- [ ] Basic error handling (map Extism errors)\n- [ ] Skip TEA helpers initially\n\n### 2. Minimal DirectRuntime (morphir-rust-direct1)\n- [ ] Create morphir-ext/src/direct.rs\n- [ ] Implement DirectRuntime wrapping ExtismRuntime\n- [ ] Simple API: execute(func_name, input_envelope) -> output_envelope\n- [ ] No actor infrastructure\n- [ ] No state management initially\n\n### 3. Minimal Host Functions (morphir-rust-std1)\n- [ ] Create morphir-ext/src/host_functions.rs\n- [ ] Implement log() function only (for debugging)\n- [ ] Register with Extism\n- [ ] Skip HTTP, workspace, IR helpers for now\n\n### 4. Migrate Extension (WASM module)\n- [ ] Create crates/morphir-migrate-extension\n- [ ] Implement backend-generate interface\n- [ ] Input: Envelope with IR v3 JSON\n- [ ] Output: Envelope with IR v4 JSON\n- [ ] Use wit-bindgen or core WASM\n- [ ] Compile to WASM (wasm32-unknown-unknown)\n\n### 5. CLI Integration\n- [ ] Update morphir CLI to support extension-based migrate\n- [ ] Load migrate.wasm using DirectRuntime\n- [ ] Read input IR file\n- [ ] Call extension with IR envelope\n- [ ] Write output IR file\n- [ ] Add --extension-path flag for WASM path\n\n### 6. Testing\n- [ ] Unit tests for ExtismRuntime\n- [ ] Unit tests for DirectRuntime\n- [ ] Integration test: Load real WASM module\n- [ ] E2E test: morphir migrate with sample IR\n- [ ] Test error handling (bad WASM, invalid IR, etc.)\n\n## Success Criteria\n- [ ] `morphir migrate input.json output.json` works end-to-end\n- [ ] Extension loaded via ExtismRuntime\n- [ ] Envelope protocol used throughout\n- [ ] No daemon required (DirectRuntime only)\n- [ ] Extension never sees Extism types\n- [ ] Clean error messages\n- [ ] Documentation of the flow\n\n## Out of Scope (for now)\n- Full TEA runtime (init/update/subscriptions)\n- DaemonClient (remote execution)\n- Full host function library\n- Complex extensions\n- Actor-based execution\n\n## After Steel Thread\nOnce working, expand to:\n- Full TEA runtime support\n- DaemonClient implementation\n- Complete host function library\n- More extensions (frontends, backends)\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md\n- morphir-ext/src/runtime.rs (ExtensionRuntime trait)\n\n## Related Issues\n- Part of WASM extension architecture (see morphir-rust-kw8)\n- Simplifies: morphir-rust-ext1, morphir-rust-direct1, morphir-rust-std1","status":"open","priority":0,"issue_type":"feature","created_at":"2026-01-29T12:30:00-06:00","created_by":"damian","updated_at":"2026-01-29T12:30:00-06:00"}
{"id":"morphir-rust-builtins","title":"Implement morphir-builtins with migrate extension","description":"Complete the implementation of morphir-builtins crate with the migrate extension as the first builtin.\n\n## Background\nBuiltin extensions are bundled with Morphir and support dual execution modes:\n- **Native**: Direct Rust implementation (always available, best performance)\n- **WASM**: Compiled to WASM for extension architecture validation\n\nThe migrate extension transforms Morphir IR between v3/classic and v4 formats.\n\n## Crate Structure Created ✅\n- [x] morphir-builtins/Cargo.toml\n- [x] morphir-builtins/src/lib.rs (BuiltinExtension trait)\n- [x] morphir-builtins/src/registry.rs (BuiltinRegistry)\n- [x] morphir-builtins/src/migrate/mod.rs (MigrateExtension skeleton)\n- [x] morphir-builtins/src/migrate/wasm.rs (WASM exports)\n- [x] morphir-builtins/README.md\n\n## Tasks\n\n### 1. Complete Migrate Implementation\n- [ ] Move/refactor existing migrate logic from CLI to morphir-builtins\n- [ ] Implement MigrateRequest/MigrateResponse properly\n- [ ] Support Classic → V4 conversion\n- [ ] Support V4 → Classic conversion\n- [ ] Handle same-format passthrough\n- [ ] Add proper error handling and warnings\n- [ ] Ensure envelope protocol is used correctly\n\n### 2. Testing\n- [ ] Unit tests for MigrateExtension::execute_native()\n- [ ] Test Classic → V4 conversion\n- [ ] Test V4 → Classic conversion\n- [ ] Test same-format scenarios\n- [ ] Test error cases (invalid IR, bad target version)\n- [ ] Integration test with actual IR files\n\n### 3. WASM Support (Optional, P2)\n- [ ] Fix WASM exports in migrate/wasm.rs\n- [ ] Create build script for WASM compilation\n- [ ] Test WASM version with ExtismRuntime\n- [ ] Add include_bytes! for WASM embedding\n\n### 4. CLI Integration\n- [ ] Update morphir CLI to use MigrateExtension (native mode)\n- [ ] Refactor existing migrate.rs to delegate to morphir-builtins\n- [ ] Add --mode flag (native vs wasm) for testing\n- [ ] Maintain backward compatibility\n\n### 5. Documentation\n- [ ] Document BuiltinExtension trait\n- [ ] Add examples to README\n- [ ] Document how to add new builtins\n- [ ] Update steel thread docs\n\n## Acceptance Criteria\n- [ ] morphir-builtins compiles successfully\n- [ ] MigrateExtension::execute_native() works for all conversions\n- [ ] All tests pass\n- [ ] CLI migrate command uses morphir-builtins (native mode)\n- [ ] Same behavior as current migrate implementation\n- [ ] Ready for WASM compilation (structure in place)\n\n## References\n- morphir-builtins/README.md\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md\n- crates/morphir/src/commands/migrate.rs (current implementation)\n\n## Related Issues\n- Part of steel thread (morphir-rust-steel-thread)\n- Part of WASM extension architecture (morphir-rust-kw8)\n- Enables: morphir-rust-direct1 (can use builtin for testing)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-29T13:00:00-06:00","created_by":"damian","updated_at":"2026-01-29T13:00:00-06:00"}
{"id":"morphir-rust-builtins-v2","title":"[UPDATED] Implement morphir-builtins with migrate extension","description":"Complete the implementation of morphir-builtins crate with the migrate extension as the first builtin.\n\n## PREREQUISITE: Gherkin Acceptance Tests Required\n\n**BEFORE IMPLEMENTATION**: Prepare comprehensive Gherkin acceptance tests and present to user for approval/iteration. Implementation may NOT proceed without user verification of tests.\n\nGherkin tests must cover:\n- Native execution: MigrateExtension::execute_native()\n- Classic → V4 conversion scenarios\n- V4 → Classic conversion scenarios\n- Same-format passthrough (no conversion)\n- Error handling (invalid IR, bad target version, malformed envelopes)\n- Warning generation (missing dependencies)\n- Envelope protocol usage (input/output envelope validation)\n- Registry discovery and access\n\n## Background\nBuiltin extensions are bundled with Morphir and support dual execution modes:\n- **Native**: Direct Rust implementation (always available, best performance)\n- **WASM**: Compiled to WASM for extension architecture validation\n\nThe migrate extension transforms Morphir IR between v3/classic and v4 formats.\n\n## Architecture\n\n```\n┌───────────────────────────────────────────────────────────────┐\n│                    morphir-builtins                           │\n│                                                               │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │         BuiltinExtension Trait                      │    │\n│  │  - execute_native(Envelope) -> Result<Envelope>     │    │\n│  │  - info() -> BuiltinInfo                            │    │\n│  │  - wasm_bytes() -> Option<&'static [u8]>           │    │\n│  └─────────────────────────────────────────────────────┘    │\n│                          ▲                                    │\n│                          │                                    │\n│           ┌──────────────┴──────────────┐                   │\n│           │                             │                    │\n│  ┌────────┴────────┐         ┌─────────┴────────┐          │\n│  │ MigrateExtension│         │ Future: TS Backend│          │\n│  │ - Native impl   │         │ - Native impl     │          │\n│  │ - WASM exports  │         │ - WASM exports    │          │\n│  └─────────────────┘         └───────────────────┘          │\n│           ▲                                                   │\n│           │                                                   │\n│  ┌────────┴──────────────────────────────────────┐          │\n│  │         BuiltinRegistry                        │          │\n│  │  - new() -> Self                               │          │\n│  │  - get(id) -> Option<&dyn BuiltinExtension>   │          │\n│  │  - list() -> Vec<BuiltinInfo>                 │          │\n│  └────────────────────────────────────────────────┘          │\n└───────────────────────────────────────────────────────────────┘\n         │                              │\n         ▼                              ▼\n   Native Mode                     WASM Mode\n   (CLI direct)                  (ExtismRuntime)\n   Fast, production            Architecture testing\n```\n\n## Crate Structure Created ✅\n- [x] morphir-builtins/Cargo.toml\n- [x] morphir-builtins/src/lib.rs (BuiltinExtension trait)\n- [x] morphir-builtins/src/registry.rs (BuiltinRegistry)\n- [x] morphir-builtins/src/migrate/mod.rs (MigrateExtension skeleton)\n- [x] morphir-builtins/src/migrate/wasm.rs (WASM exports)\n- [x] morphir-builtins/README.md\n\n## Tasks\n\n### 0. **FIRST: Create Gherkin acceptance tests and get user approval**\n- [ ] Write Gherkin scenarios for all conversion paths\n- [ ] Present to user for review/iteration\n- [ ] Get explicit approval before proceeding\n\n### 1. Complete Migrate Implementation\n- [ ] Move/refactor existing migrate logic from CLI to morphir-builtins\n- [ ] Implement MigrateRequest/MigrateResponse properly\n- [ ] Support Classic → V4 conversion\n- [ ] Support V4 → Classic conversion\n- [ ] Handle same-format passthrough\n- [ ] Add proper error handling and warnings\n- [ ] Ensure envelope protocol is used correctly\n\n### 2. Testing\n- [ ] All Gherkin scenarios pass\n- [ ] Unit tests for MigrateExtension::execute_native()\n- [ ] Test Classic → V4 conversion\n- [ ] Test V4 → Classic conversion\n- [ ] Test same-format scenarios\n- [ ] Test error cases (invalid IR, bad target version)\n- [ ] Integration test with actual IR files\n\n### 3. WASM Support (Optional, P2)\n- [ ] Fix WASM exports in migrate/wasm.rs\n- [ ] Create build script for WASM compilation\n- [ ] Test WASM version with ExtismRuntime\n- [ ] Add include_bytes! for WASM embedding\n\n### 4. CLI Integration\n- [ ] Update morphir CLI to use MigrateExtension (native mode)\n- [ ] Refactor existing migrate.rs to delegate to morphir-builtins\n- [ ] Add --mode flag (native vs wasm) for testing\n- [ ] Maintain backward compatibility\n\n### 5. Documentation\n- [ ] Document BuiltinExtension trait\n- [ ] Add examples to README\n- [ ] Document how to add new builtins\n- [ ] Update steel thread docs\n\n## Acceptance Criteria\n- [ ] **Gherkin tests approved by user before implementation**\n- [ ] All Gherkin scenarios pass\n- [ ] morphir-builtins compiles successfully\n- [ ] MigrateExtension::execute_native() works for all conversions\n- [ ] All tests pass\n- [ ] CLI migrate command uses morphir-builtins (native mode)\n- [ ] Same behavior as current migrate implementation\n- [ ] Ready for WASM compilation (structure in place)\n\n## References\n- morphir-builtins/README.md\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md\n- crates/morphir/src/commands/migrate.rs (current implementation)\n- ~/AGENTS.md - Gherkin Acceptance Test Requirement\n\n## Related Issues\n- Part of steel thread (morphir-rust-steel-thread)\n- Part of WASM extension architecture (morphir-rust-kw8)\n- Enables: morphir-rust-direct1 (can use builtin for testing)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-29T13:30:00-06:00","created_by":"damian","updated_at":"2026-01-29T13:30:00-06:00"}
{"id":"morphir-rust-direct1-v2","title":"[UPDATED] Implement DirectRuntime for direct execution mode","description":"Implement DirectRuntime in morphir-ext for direct execution without actors or IPC, supporting CLI, Morphir-Live, and browser/WASM environments.\n\n## PREREQUISITE: Gherkin Acceptance Tests Required\n\n**BEFORE IMPLEMENTATION**: Prepare comprehensive Gherkin acceptance tests and present to user for approval/iteration. Implementation may NOT proceed without user verification of tests.\n\nGherkin tests must cover:\n- DirectRuntime construction with ExtismRuntime\n- execute() method with various function names and envelopes\n- TEA lifecycle: init(), update(), subscriptions()\n- Design-time operations: backend_generate(), frontend_compile()\n- Error handling (WASM errors, envelope errors, missing functions)\n- No dependency on Kameo or daemon infrastructure\n- Works in WASM context (no_std compatible if needed)\n\n## Background\nDirectRuntime provides in-process extension execution without daemon/actor overhead. All clients (CLI, Morphir-Live, browser/WASM) can use DirectRuntime for embedded execution.\n\n## Architecture\n\n```\n┌────────────────────────────────────────────────────────────┐\n│                     Client Layer                           │\n│  (CLI, Morphir-Live, Browser/WASM, IDE)                   │\n└──────────────────────┬─────────────────────────────────────┘\n                       │\n                       │ Choice: Direct or Daemon\n                       │\n            ┌──────────┴──────────┐\n            │                     │\n            ▼                     ▼\n  ┌──────────────────┐   ┌─────────────────┐\n  │  DirectRuntime   │   │  DaemonClient   │\n  │  (morphir-ext)   │   │  (morphir-ext)  │\n  └────────┬─────────┘   └────────┬────────┘\n           │                      │\n           │ No IPC               │ IPC (JSON-RPC)\n           │                      │\n           ▼                      ▼\n  ┌──────────────────┐   ┌─────────────────┐\n  │ ExtismRuntime    │   │  Daemon Service │\n  │ (morphir-ext)    │   │  with actors    │\n  └────────┬─────────┘   └─────────────────┘\n           │\n           │ Loads WASM\n           ▼\n  ┌──────────────────┐\n  │  Extension       │\n  │  (WASM module)   │\n  └──────────────────┘\n\nDirectRuntime Flow:\n━━━━━━━━━━━━━━━━━━\nClient\n  │\n  └─> DirectRuntime::new(ExtismRuntime)\n        │\n        └─> execute(\"backend_generate\", envelope)\n              │\n              └─> ExtismRuntime::call_envelope()\n                    │\n                    └─> Extism loads WASM\n                          │\n                          └─> Calls backend_generate()\n                                │\n                                └─> Returns envelope\n```\n\n## Implementation Location\n- **File**: `morphir-ext/src/direct.rs`\n- **Depends on**: `morphir-ext/src/runtime.rs` (ExtensionRuntime trait)\n- **Uses**: `morphir-ext/src/extism_runtime.rs` (ExtismRuntime)\n\n## Tasks\n\n### 0. **FIRST: Create Gherkin acceptance tests and get user approval**\n- [ ] Write Gherkin scenarios for DirectRuntime usage\n- [ ] Include all execution modes (TEA + design-time)\n- [ ] Present to user for review/iteration\n- [ ] Get explicit approval before proceeding\n\n### 1. Core Implementation\n- [ ] Create `morphir-ext/src/direct.rs` module\n- [ ] Implement DirectRuntime struct\n- [ ] Wrap ExtensionInstance (which wraps ExtensionRuntime)\n- [ ] Simple execute() API: `execute(func_name, input) -> Result<Envelope>`\n- [ ] No actor infrastructure, no IPC\n- [ ] No state management initially (stateless calls)\n\n### 2. TEA Support\n- [ ] Add init() helper method\n- [ ] Add update() helper method\n- [ ] Add subscriptions() helper method\n- [ ] Maintain model state if needed\n\n### 3. Design-Time Support\n- [ ] Support backend_generate() calls\n- [ ] Support frontend_compile() calls\n- [ ] Support get_capabilities() calls\n\n### 4. Error Handling\n- [ ] Map ExtismRuntime errors to DirectRuntime errors\n- [ ] Provide clear error messages\n- [ ] Handle missing functions gracefully\n- [ ] Handle envelope encoding/decoding errors\n\n### 5. Testing\n- [ ] All Gherkin scenarios pass\n- [ ] Unit tests with mock ExtensionRuntime\n- [ ] Integration tests with real WASM (morphir-builtins migrate)\n- [ ] Test in no_std context if targeting WASM\n- [ ] Test error paths\n\n### 6. Documentation\n- [ ] API documentation\n- [ ] Usage examples (native and WASM contexts)\n- [ ] Comparison with DaemonClient\n\n## Acceptance Criteria\n- [ ] **Gherkin tests approved by user before implementation**\n- [ ] All Gherkin scenarios pass\n- [ ] DirectRuntime compiles for native and wasm32-unknown-unknown\n- [ ] Can execute migrate builtin in native mode\n- [ ] TEA lifecycle methods work\n- [ ] Design-time operations work\n- [ ] No Kameo or daemon dependencies\n- [ ] Clean error handling\n- [ ] Documented with examples\n\n## References\n- docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md\n- morphir-ext/src/runtime.rs (ExtensionRuntime trait, ExtensionInstance)\n- morphir-ext/src/actor.rs (actor-based alternative)\n- ~/AGENTS.md - Gherkin Acceptance Test Requirement\n\n## Related Issues\n- Depends on: morphir-rust-ext1 (ExtismRuntime)\n- Used by: morphir-rust-steel-thread (CLI integration)\n- Enables: morphir-rust-builtins-v2 (testing native + WASM)\n- Part of WASM extension architecture (morphir-rust-kw8)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-29T14:00:00-06:00","created_by":"damian","updated_at":"2026-01-29T14:00:00-06:00"}
{"id":"morphir-rust-steel-thread-v2","title":"[UPDATED] Steel Thread with Integration Test Plan","description":"Build end-to-end working migrate command with comprehensive integration testing.\n\n## PREREQUISITE: Review Integration Test Plan\n\n**BEFORE IMPLEMENTATION**: Review the integration test plan and Gherkin scenarios:\n- docs/contributors/testing/steel-thread-integration-test-plan.md\n- crates/integration-tests/tests/features/steel-thread.feature\n\nProvide feedback or approval before implementation begins.\n\n## Goal\nDemonstrate the extension architecture with a real, working command: `morphir migrate` with full integration test coverage.\n\n## Architecture Flow\n\n```\nCLI (morphir migrate)\n  │\n  ├─> morphir-builtins::MigrateExtension (native mode)\n  │     │\n  │     └─> execute_native(&Envelope)\n  │           │\n  │           └─> Returns Envelope\n  │\n  └─> [P2] DirectRuntime + ExtismRuntime (WASM mode)\n        │\n        └─> Loads migrate.wasm\n              │\n              └─> Calls via Extism\n\nTest Pyramid:\n                     ┌─────────────────┐\n                     │  E2E CLI Tests  │  ← steel-thread.feature\n                     │  (Gherkin)      │     (26 scenarios)\n                     └────────┬────────┘\n                              │\n                    ┌─────────┴──────────┐\n                    │  Component Tests   │  ← per-crate Gherkin\n                    │  (Rust + Gherkin)  │     + unit tests\n                    └─────────┬──────────┘\n                              │\n                    ┌─────────┴─────────┐\n                    │   Unit Tests      │  ← function-level\n                    │   (Rust)          │     (per-module)\n                    └───────────────────┘\n```\n\n## Implementation Steps\n\n### 0. **FIRST: Review and Approve Integration Test Plan**\n- [ ] Review docs/contributors/testing/steel-thread-integration-test-plan.md\n- [ ] Review crates/integration-tests/tests/features/steel-thread.feature\n- [ ] Provide feedback or explicit approval\n\n### 1. Minimal ExtismRuntime (morphir-rust-ext1)\n- [ ] Create Gherkin tests for ExtismRuntime\n- [ ] Get user approval on Gherkin scenarios\n- [ ] Implement morphir-ext/src/extism_runtime.rs\n- [ ] Implement call_envelope() method only\n- [ ] Load WASM via Extism Manifest\n- [ ] Basic error handling\n- [ ] All Gherkin tests pass\n\n### 2. Minimal DirectRuntime (morphir-rust-direct1)\n- [ ] Create Gherkin tests for DirectRuntime\n- [ ] Get user approval on Gherkin scenarios\n- [ ] Implement morphir-ext/src/direct.rs\n- [ ] Wrap ExtismRuntime\n- [ ] Simple execute() API\n- [ ] All Gherkin tests pass\n\n### 3. Minimal Host Functions (morphir-rust-std1)\n- [ ] Create Gherkin tests for host functions\n- [ ] Get user approval on Gherkin scenarios\n- [ ] Implement morphir-ext/src/host_functions.rs\n- [ ] Implement log() function only\n- [ ] Register with Extism\n- [ ] All Gherkin tests pass\n\n### 4. Complete MigrateExtension (morphir-rust-builtins-v2)\n- [ ] Create Gherkin tests for migrate extension\n- [ ] Get user approval on Gherkin scenarios\n- [ ] Move migrate logic from CLI to morphir-builtins\n- [ ] Implement native execution path\n- [ ] Support all conversion paths (Classic↔V4)\n- [ ] All Gherkin tests pass\n\n### 5. CLI Integration\n- [ ] Update morphir CLI to use MigrateExtension\n- [ ] Refactor migrate.rs to delegate to morphir-builtins\n- [ ] Maintain backward compatibility\n- [ ] Add --mode flag (native/wasm) for future\n\n### 6. Integration Testing\n- [ ] Implement test runner: integration-tests/tests/steel_thread.rs\n- [ ] Add test fixtures to fixtures/steel-thread/\n- [ ] Run P0 scenarios (native mode): 13 scenarios\n- [ ] All P0 steel-thread.feature scenarios pass\n- [ ] Document any failures or issues\n\n### 7. WASM Mode (P2 - Future)\n- [ ] Compile morphir-builtins to WASM\n- [ ] Test WASM version with DirectRuntime\n- [ ] Run P2 scenarios (WASM mode): 3 scenarios\n- [ ] Performance comparison (native vs WASM)\n\n## Test Coverage Breakdown\n\n### steel-thread.feature (26 scenarios)\n\n**P0 - Native Mode (13 scenarios):**\n- ✅ Classic → V4 migration\n- ✅ V4 → Classic migration\n- ✅ Same-format no-ops\n- ✅ Error handling (invalid version, missing file, malformed IR)\n- ✅ Stdout output with JSON mode\n- ✅ Dependency warnings\n- ✅ Expanded format option\n- ✅ Envelope protocol validation\n\n**P1 - Remote Sources (3 scenarios):**\n- ✅ HTTP URL sources\n- ✅ Force refresh\n- ✅ No cache option\n\n**P2 - WASM Mode (3 scenarios):**\n- ✅ WASM execution\n- ✅ Native vs WASM result comparison\n- ✅ Performance benchmarking\n\n**P1 - Regression (3 scenarios):**\n- ✅ Module structure preservation\n- ✅ Type definitions preservation\n- ✅ Value definitions preservation\n\n**P0 - Envelope Protocol (2 scenarios):**\n- ✅ Protocol usage validation\n- ✅ Metadata validation\n\n## Success Criteria (MVP)\n\n- [ ] All morphir-builtins Gherkin tests pass\n- [ ] All morphir-ext Gherkin tests pass\n- [ ] `morphir migrate` works with native builtin\n- [ ] All 13 P0 steel-thread.feature scenarios pass\n- [ ] Classic → V4 conversion validated end-to-end\n- [ ] V4 → Classic conversion validated end-to-end\n- [ ] Error handling works (3 error scenarios pass)\n- [ ] Envelope protocol validated (2 envelope scenarios pass)\n- [ ] CI runs steel thread tests on every commit\n\n## Success Criteria (Extended - P2)\n\n- [ ] morphir-builtins compiled to WASM\n- [ ] `morphir migrate --mode wasm` works\n- [ ] All 3 P2 WASM scenarios pass\n- [ ] Native and WASM produce identical results\n- [ ] Performance comparison documented\n\n## CI/CD Integration\n\n```yaml\nname: Steel Thread Tests\njobs:\n  steel-thread:\n    steps:\n      - Build CLI\n      - Run unit tests (all components)\n      - Run component Gherkin tests\n      - Run steel-thread.feature (P0 scenarios)\n      - Generate coverage report\n      - Upload test results\n```\n\n## References\n\n- Integration Test Plan: docs/contributors/testing/steel-thread-integration-test-plan.md\n- Gherkin Scenarios: crates/integration-tests/tests/features/steel-thread.feature\n- Architecture Doc: docs/contributors/design/extensions/actor-based/12-wasm-extension-architecture-session.md\n- ADR-0001: Envelope-Only Execution\n\n## Related Issues\n\n- morphir-rust-ext1: ExtismRuntime (with Gherkin tests)\n- morphir-rust-direct1: DirectRuntime (with Gherkin tests)\n- morphir-rust-std1: Host functions (with Gherkin tests)\n- morphir-rust-builtins-v2: Builtin extensions (with Gherkin tests)\n- Part of: morphir-rust-kw8 (WASM extension architecture)","status":"open","priority":0,"issue_type":"feature","created_at":"2026-01-29T15:00:00-06:00","created_by":"damian","updated_at":"2026-01-29T15:00:00-06:00"}