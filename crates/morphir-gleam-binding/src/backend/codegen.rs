//! Gleam code generation from Morphir IR

use morphir_common::vfs::{OsVfs, Vfs};
use morphir_extension_sdk::prelude::*;
use morphir_ir::ir::v4::PackageDefinition;
use morphir_ir::naming::ModuleName;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt::Write;
use std::path::PathBuf;

/// Morphir distribution IR (simplified)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Distribution {
    #[serde(default)]
    pub name: String,
    pub modules: Vec<ModuleIR>,
}

/// Module IR representation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleIR {
    pub name: String,
    #[serde(default)]
    pub types: Vec<TypeDef>,
    #[serde(default)]
    pub values: Vec<ValueDef>,
}

/// Type definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TypeDef {
    pub name: String,
    #[serde(default)]
    pub params: Vec<String>,
    pub body: serde_json::Value,
}

/// Value definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValueDef {
    pub name: String,
    #[serde(default)]
    pub body: serde_json::Value,
}

/// Generate Gleam code from Morphir IR
pub fn generate_gleam(
    ir: &serde_json::Value,
    options: &HashMap<String, serde_json::Value>,
) -> Result<Vec<Artifact>> {
    // Try to parse as V4 PackageDefinition first
    if let Ok(package_def) = serde_json::from_value::<PackageDefinition>(ir.clone()) {
        return generate_from_package_definition(package_def, options);
    }

    // Fallback to legacy format
    let mut artifacts = Vec::new();

    // Try to parse as distribution or module list
    let modules: Vec<ModuleIR> =
        if let Ok(dist) = serde_json::from_value::<Distribution>(ir.clone()) {
            dist.modules
        } else if let Ok(modules) = serde_json::from_value::<Vec<ModuleIR>>(ir.clone()) {
            modules
        } else {
            // Try single module
            vec![serde_json::from_value::<ModuleIR>(ir.clone())?]
        };

    let pretty = options
        .get("format")
        .and_then(|v| v.as_str())
        .map(|s| s == "pretty")
        .unwrap_or(true);

    for module in modules {
        let code = generate_module(&module, pretty);
        let path = format!("{}.gleam", module.name.replace('_', "/"));

        artifacts.push(Artifact {
            path,
            content: code,
            binary: false,
        });
    }

    Ok(artifacts)
}

/// Generate from V4 PackageDefinition using visitor
fn generate_from_package_definition(
    package_def: PackageDefinition,
    options: &HashMap<String, serde_json::Value>,
) -> Result<Vec<Artifact>> {
    use super::visitor::MorphirToGleamVisitor;

    let output_dir = options
        .get("outputDir")
        .and_then(|v| v.as_str())
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("."));

    let package_name = options
        .get("packageName")
        .and_then(|v| v.as_str())
        .map(String::from)
        .unwrap_or_else(|| "default-package".to_string());

    let visitor = MorphirToGleamVisitor::new(OsVfs, output_dir.clone(), package_name);

    let mut artifacts = Vec::new();

    // Generate each module
    for (module_path_str, module_def) in &package_def.modules {
        let module_path = ModuleName::parse(module_path_str);

        match visitor.visit_module(&module_path, module_def) {
            Ok(_) => {
                // Read generated file using a new OsVfs instance
                let file_path = output_dir.join(format!("{}.gleam", module_path_str));
                let read_vfs = OsVfs;
                if read_vfs.exists(&file_path) {
                    match read_vfs.read_to_string(&file_path) {
                        Ok(content) => {
                            artifacts.push(Artifact {
                                path: format!("{}.gleam", module_path_str),
                                content,
                                binary: false,
                            });
                        }
                        Err(e) => {
                            return Err(ExtensionError::execution(format!("Failed to read generated file: {}", e)));
                        }
                    }
                }
            }
            Err(e) => {
                return Err(ExtensionError::execution(format!(
                    "Failed to generate module {}: {}",
                    module_path_str,
                    e
                )));
            }
        }
    }

    Ok(artifacts)
}

/// Generate code for a single module
fn generate_module(module: &ModuleIR, pretty: bool) -> String {
    let mut output = String::new();
    let indent = if pretty { "  " } else { "" };

    // Module header comment - String's Write never fails
    let _ = writeln!(output, "// Generated by Morphir Gleam Backend");
    let _ = writeln!(output, "// Module: {}", module.name);
    let _ = writeln!(output);

    // Generate type definitions
    for type_def in &module.types {
        generate_type(&mut output, type_def, indent);
        let _ = writeln!(output);
    }

    // Generate value definitions
    for value_def in &module.values {
        generate_value(&mut output, value_def, indent);
        let _ = writeln!(output);
    }

    output
}

/// Generate a type definition
fn generate_type(output: &mut String, type_def: &TypeDef, indent: &str) {
    let type_params = if type_def.params.is_empty() {
        String::new()
    } else {
        format!("({})", type_def.params.join(", "))
    };

    let _ = writeln!(output, "pub type {}{} {{", type_def.name, type_params);

    // Generate type body based on structure
    if let Some(obj) = type_def.body.as_object() {
        if let Some(kind) = obj.get("kind").and_then(|v| v.as_str()) {
            match kind {
                "customType" => {
                    if let Some(variants) = obj.get("variants").and_then(|v| v.as_array()) {
                        for variant in variants {
                            if let Some(name) = variant.get("name").and_then(|v| v.as_str()) {
                                let _ = writeln!(output, "{}{}", indent, name);
                            }
                        }
                    }
                }
                "record" => {
                    if let Some(fields) = obj.get("fields").and_then(|v| v.as_array()) {
                        for field in fields {
                            if let Some(arr) = field.as_array() {
                                if arr.len() >= 2 {
                                    if let (Some(name), Some(_type_expr)) =
                                        (arr[0].as_str(), arr.get(1))
                                    {
                                        let _ = writeln!(output, "{}{}: Unknown,", indent, name);
                                    }
                                }
                            }
                        }
                    }
                }
                _ => {
                    let _ = writeln!(output, "{}// Unknown type kind: {}", indent, kind);
                }
            }
        }
    } else {
        let _ = writeln!(output, "{}// Type body: {:?}", indent, type_def.body);
    }

    let _ = writeln!(output, "}}");
}

/// Generate a value definition
fn generate_value(output: &mut String, value_def: &ValueDef, indent: &str) {
    let _ = writeln!(output, "pub fn {}() {{", value_def.name);

    // Generate body based on structure
    if let Some(obj) = value_def.body.as_object() {
        if let Some(kind) = obj.get("kind").and_then(|v| v.as_str()) {
            match kind {
                "literal" => {
                    if let Some(value) = obj.get("value") {
                        if let Some(lit_obj) = value.as_object() {
                            if let Some(lit_type) = lit_obj.get("type").and_then(|v| v.as_str()) {
                                match lit_type {
                                    "string" => {
                                        if let Some(s) =
                                            lit_obj.get("value").and_then(|v| v.as_str())
                                        {
                                            let _ = writeln!(output, "{}\"{}\"", indent, s);
                                        }
                                    }
                                    "int" => {
                                        if let Some(n) =
                                            lit_obj.get("value").and_then(|v| v.as_i64())
                                        {
                                            let _ = writeln!(output, "{}{}", indent, n);
                                        }
                                    }
                                    "bool" => {
                                        if let Some(b) =
                                            lit_obj.get("value").and_then(|v| v.as_bool())
                                        {
                                            let _ = writeln!(
                                                output,
                                                "{}{}",
                                                indent,
                                                if b { "True" } else { "False" }
                                            );
                                        }
                                    }
                                    _ => {
                                        let _ = writeln!(
                                            output,
                                            "{}// Unknown literal type: {}",
                                            indent, lit_type
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
                "variable" => {
                    if let Some(name) = obj.get("name").and_then(|v| v.as_str()) {
                        let _ = writeln!(output, "{}{}", indent, name);
                    }
                }
                _ => {
                    let _ = writeln!(output, "{}// Expression kind: {}", indent, kind);
                    let _ = writeln!(output, "{}todo", indent);
                }
            }
        }
    } else {
        let _ = writeln!(output, "{}todo", indent);
    }

    let _ = writeln!(output, "}}");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_simple_module() {
        let ir = serde_json::json!({
            "name": "example",
            "types": [],
            "values": [{
                "name": "hello",
                "body": {
                    "kind": "literal",
                    "value": {
                        "type": "string",
                        "value": "world"
                    }
                }
            }]
        });

        let options = HashMap::new();
        let result = generate_gleam(&ir, &options).unwrap();

        assert_eq!(result.len(), 1);
        assert!(result[0].path.contains("example"));
        assert!(result[0].content.contains("pub fn hello()"));
        assert!(result[0].content.contains("\"world\""));
    }
}
