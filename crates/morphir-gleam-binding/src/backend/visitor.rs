//! Backend visitor - converts Morphir IR V4 to Gleam source code
//!
//! This visitor traverses Morphir IR structures and generates Gleam source code,
//! using Vfs for file generation.

use morphir_common::vfs::Vfs;
use morphir_ir::ir::attributes::{TypeAttributes, ValueAttributes};
use morphir_ir::ir::literal::Literal as MorphirLiteral;
use morphir_ir::ir::pattern::Pattern as MorphirPattern;
use morphir_ir::ir::type_expr::Type;
use morphir_ir::ir::v4::{
    Access as MorphirAccess, AccessControlledModuleDefinition, AccessControlledTypeDefinition,
    AccessControlledValueDefinition, ModuleDefinition,
};
use morphir_ir::ir::value_expr::{RecordFieldEntry, Value, ValueDefinition};
use morphir_ir::naming::{FQName, ModuleName, Name};
use std::io::Result;
use std::path::PathBuf;

/// Visitor that converts Morphir IR V4 to Gleam source code
pub struct MorphirToGleamVisitor<V: Vfs> {
    vfs: V,
    output_dir: PathBuf,
    package_name: String,
}

impl<V: Vfs> MorphirToGleamVisitor<V> {
    /// Create a new visitor
    pub fn new(vfs: V, output_dir: PathBuf, package_name: String) -> Self {
        Self {
            vfs,
            output_dir,
            package_name,
        }
    }

    /// Convert ModuleDefinition to Gleam source file
    pub fn visit_module(
        &self,
        module_path: &ModuleName,
        module: &AccessControlledModuleDefinition,
    ) -> Result<()> {
        // Convert module path to file path: "my/module" -> "my/module.gleam"
        let file_path = self.output_dir.join(format!(
            "{}.gleam",
            module_path.to_string().replace("/", "/")
        ));

        // Generate module content
        let content = self.generate_module_content(module_path, &module.value)?;

        // Write to Vfs
        self.vfs.write_from_string(&file_path, &content)?;
        Ok(())
    }

    /// Generate module content as string
    fn generate_module_content(
        &self,
        _module_path: &ModuleName,
        module: &ModuleDefinition,
    ) -> Result<String> {
        let mut output = String::new();

        // Module header comment
        output.push_str("// Generated by Morphir Gleam Backend\n");
        output.push_str("\n");

        // Generate type definitions
        for (type_name, type_def) in &module.types {
            self.generate_type_def(&mut output, type_name, type_def)?;
            output.push_str("\n");
        }

        // Generate value definitions
        for (value_name, value_def) in &module.values {
            self.generate_value_def(&mut output, value_name, value_def)?;
            output.push_str("\n");
        }

        Ok(output)
    }

    /// Generate a type definition
    fn generate_type_def(
        &self,
        output: &mut String,
        type_name: &str,
        type_def: &AccessControlledTypeDefinition,
    ) -> Result<()> {
        use morphir_ir::ir::v4::TypeDefinition;

        // Access control
        if matches!(type_def.access, MorphirAccess::Public) {
            output.push_str("pub ");
        }

        output.push_str("type ");
        output.push_str(type_name);

        // Type parameters
        match &type_def.value {
            TypeDefinition::TypeAliasDefinition { type_params, .. } => {
                if !type_params.is_empty() {
                    output.push_str("(");
                    for (i, param) in type_params.iter().enumerate() {
                        if i > 0 {
                            output.push_str(", ");
                        }
                        output.push_str(&param.to_string());
                    }
                    output.push_str(")");
                }
            }
            TypeDefinition::CustomTypeDefinition { type_params, .. } => {
                if !type_params.is_empty() {
                    output.push_str("(");
                    for (i, param) in type_params.iter().enumerate() {
                        if i > 0 {
                            output.push_str(", ");
                        }
                        output.push_str(&param.to_string());
                    }
                    output.push_str(")");
                }
            }
        }

        output.push_str(" {\n");

        match &type_def.value {
            TypeDefinition::TypeAliasDefinition { type_expr, .. } => {
                // Type alias - generate type expression
                // For now, simplified - would need to convert type_expr JSON to Gleam syntax
                output.push_str("  // Type alias\n");
            }
            TypeDefinition::CustomTypeDefinition { constructors, .. } => {
                // Custom type - generate constructors
                for (i, constructor) in constructors.value.iter().enumerate() {
                    if i > 0 {
                        output.push_str("  | ");
                    } else {
                        output.push_str("  ");
                    }
                    output.push_str(&constructor.name.to_string());

                    if !constructor.args.is_empty() {
                        output.push_str("(");
                        for (j, arg) in constructor.args.iter().enumerate() {
                            if j > 0 {
                                output.push_str(", ");
                            }
                            // For now, simplified - would need to convert arg_type JSON
                            output.push_str("_");
                        }
                        output.push_str(")");
                    }

                    output.push_str("\n");
                }
            }
        }

        output.push_str("}\n");
        Ok(())
    }

    /// Generate a value definition
    fn generate_value_def(
        &self,
        output: &mut String,
        value_name: &str,
        value_def: &AccessControlledValueDefinition,
    ) -> Result<()> {
        // Access control
        if matches!(value_def.access, MorphirAccess::Public) {
            output.push_str("pub ");
        }

        output.push_str("fn ");
        output.push_str(value_name);
        output.push_str("(");

        // Parameters
        for (i, input) in value_def.value.input_types.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&input.0.to_string());
        }

        output.push_str(") {\n");

        // Body - V4 stores body as JSON, so we generate based on the JSON representation
        match &value_def.value.body {
            morphir_ir::ir::v4::ValueBody::ExpressionBody { body } => {
                // For now, output the JSON as a todo placeholder
                // A full implementation would deserialize and generate proper Gleam code
                output.push_str("  todo // ");
                output.push_str(&body.to_string());
            }
            morphir_ir::ir::v4::ValueBody::NativeBody { hint, .. } => {
                output.push_str("  // native: ");
                output.push_str(&format!("{:?}", hint));
            }
            morphir_ir::ir::v4::ValueBody::ExternalBody { external_name, .. } => {
                output.push_str("  // external: ");
                output.push_str(external_name);
            }
            morphir_ir::ir::v4::ValueBody::IncompleteBody { .. } => {
                output.push_str("  todo // incomplete");
            }
        }

        output.push_str("\n}\n");
        Ok(())
    }

    /// Generate value expression
    fn generate_value_expr(
        &self,
        output: &mut String,
        value: &Value<TypeAttributes, ValueAttributes>,
    ) -> Result<()> {
        match value {
            Value::Literal(_, lit) => {
                self.generate_literal(output, lit)?;
            }
            Value::Variable(_, name) => {
                output.push_str(&name.to_string());
            }
            Value::Apply(_, function, argument) => {
                self.generate_value_expr(output, function)?;
                output.push_str("(");
                self.generate_value_expr(output, argument)?;
                output.push_str(")");
            }
            Value::Lambda(_, param, body) => {
                output.push_str("fn(");
                // TODO: Extract param name from pattern
                output.push_str("_");
                output.push_str(") { ");
                self.generate_value_expr(output, body)?;
                output.push_str(" }");
            }
            Value::LetDefinition(_, name, def, body) => {
                output.push_str("let ");
                output.push_str(&name.to_string());
                output.push_str(" = ");
                self.generate_value_expr(output, def.body.get_expression()?)?;
                output.push_str(" in ");
                self.generate_value_expr(output, body)?;
            }
            Value::IfThenElse(_, condition, then_branch, else_branch) => {
                output.push_str("if ");
                self.generate_value_expr(output, condition)?;
                output.push_str(" { ");
                self.generate_value_expr(output, then_branch)?;
                output.push_str(" } else { ");
                self.generate_value_expr(output, else_branch)?;
                output.push_str(" }");
            }
            Value::Record(_, fields) => {
                output.push_str("{ ");
                for (i, field) in fields.iter().enumerate() {
                    if i > 0 {
                        output.push_str(", ");
                    }
                    output.push_str(&field.0.to_string());
                    output.push_str(": ");
                    self.generate_value_expr(output, &field.1)?;
                }
                output.push_str(" }");
            }
            Value::Field(_, record, field) => {
                self.generate_value_expr(output, record)?;
                output.push_str(".");
                output.push_str(&field.to_string());
            }
            Value::Tuple(_, elements) => {
                output.push_str("#(");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        output.push_str(", ");
                    }
                    self.generate_value_expr(output, elem)?;
                }
                output.push_str(")");
            }
            Value::PatternMatch(_, subject, cases) => {
                output.push_str("case ");
                self.generate_value_expr(output, subject)?;
                output.push_str(" { ");
                for (i, case) in cases.iter().enumerate() {
                    if i > 0 {
                        output.push_str(", ");
                    }
                    self.generate_pattern(output, &case.0)?;
                    output.push_str(" -> ");
                    self.generate_value_expr(output, &case.1)?;
                }
                output.push_str(" }");
            }
            Value::Constructor(_, fqname) => {
                output.push_str(&fqname.local_name.to_string());
            }
            _ => {
                output.push_str("todo");
            }
        }
        Ok(())
    }

    /// Generate pattern
    fn generate_pattern(
        &self,
        output: &mut String,
        pattern: &MorphirPattern<ValueAttributes>,
    ) -> Result<()> {
        match pattern {
            MorphirPattern::WildcardPattern(_) => {
                output.push_str("_");
            }
            MorphirPattern::AsPattern(_, sub_pattern, name) => {
                self.generate_pattern(output, sub_pattern)?;
                output.push_str(" as ");
                output.push_str(&name.to_string());
            }
            MorphirPattern::TuplePattern(_, elements) => {
                output.push_str("#(");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        output.push_str(", ");
                    }
                    self.generate_pattern(output, elem)?;
                }
                output.push_str(")");
            }
            MorphirPattern::ConstructorPattern(_, fqname, args) => {
                output.push_str(&fqname.local_name.to_string());
                if !args.is_empty() {
                    output.push_str("(");
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 {
                            output.push_str(", ");
                        }
                        self.generate_pattern(output, arg)?;
                    }
                    output.push_str(")");
                }
            }
            MorphirPattern::LiteralPattern(_, lit) => {
                self.generate_literal(output, lit)?;
            }
            _ => {
                output.push_str("_");
            }
        }
        Ok(())
    }

    /// Generate literal
    pub(crate) fn generate_literal(&self, output: &mut String, lit: &MorphirLiteral) -> Result<()> {
        match lit {
            MorphirLiteral::Bool(b) => {
                output.push_str(if *b { "True" } else { "False" });
            }
            MorphirLiteral::Integer(i) => {
                output.push_str(&i.to_string());
            }
            MorphirLiteral::Float(f) => {
                output.push_str(&f.to_string());
            }
            MorphirLiteral::String(s) => {
                output.push_str("\"");
                output.push_str(s);
                output.push_str("\"");
            }
            MorphirLiteral::Char(c) => {
                output.push_str("'");
                output.push_str(&c.to_string());
                output.push_str("'");
            }
            MorphirLiteral::Decimal(d) => {
                output.push_str(d);
            }
        }
        Ok(())
    }
}

// Helper trait for ValueBody
trait ValueBodyExt {
    fn get_expression(&self) -> Result<&Value<TypeAttributes, ValueAttributes>>;
}

impl ValueBodyExt for morphir_ir::ir::value_expr::ValueBody<TypeAttributes, ValueAttributes> {
    fn get_expression(&self) -> Result<&Value<TypeAttributes, ValueAttributes>> {
        match self {
            morphir_ir::ir::value_expr::ValueBody::Expression(expr) => Ok(expr),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Expected expression body",
            )),
        }
    }
}

// Helper trait for V4 ValueBody
trait V4ValueBodyExt {
    fn get_expression_json(&self) -> Result<&serde_json::Value>;
}

impl V4ValueBodyExt for morphir_ir::ir::v4::ValueBody {
    fn get_expression_json(&self) -> Result<&serde_json::Value> {
        match self {
            morphir_ir::ir::v4::ValueBody::ExpressionBody { body } => Ok(body),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Expected expression body",
            )),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use indexmap::IndexMap;
    use morphir_common::vfs::MemoryVfs;
    use morphir_ir::ir::v4::Access as MorphirAccess;
    use morphir_ir::ir::v4::{AccessControlledModuleDefinition, ModuleDefinition};
    use morphir_ir::naming::ModuleName;
    use std::path::PathBuf;

    #[test]
    fn test_generate_module() {
        let vfs = MemoryVfs::new();
        let output_dir = PathBuf::from("/test");
        let package_name = "test-package".to_string();
        let visitor = MorphirToGleamVisitor::new(vfs, output_dir, package_name);

        let module_name = ModuleName::parse("test_module");
        let module_def = AccessControlledModuleDefinition {
            access: MorphirAccess::Public,
            value: ModuleDefinition {
                types: IndexMap::new(),
                values: IndexMap::new(),
                doc: None,
            },
        };

        // Test that visitor can generate module
        let result = visitor.visit_module(&module_name, &module_def);
        assert!(result.is_ok());
    }

    #[test]
    fn test_generate_literal() {
        let vfs = MemoryVfs::new();
        let visitor = MorphirToGleamVisitor::new(vfs, PathBuf::from("/test"), "test".to_string());

        let mut output = String::new();
        let lit = MorphirLiteral::Bool(true);
        visitor.generate_literal(&mut output, &lit).unwrap();
        assert_eq!(output, "True");

        output.clear();
        let lit = MorphirLiteral::Integer(42);
        visitor.generate_literal(&mut output, &lit).unwrap();
        assert_eq!(output, "42");

        output.clear();
        let lit = MorphirLiteral::String("hello".to_string());
        visitor.generate_literal(&mut output, &lit).unwrap();
        assert_eq!(output, "\"hello\"");
    }
}
