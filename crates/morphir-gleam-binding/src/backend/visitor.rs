//! Backend visitor - converts Morphir IR V4 to Gleam source code
//!
//! This visitor traverses Morphir IR structures and generates Gleam source code,
//! using Vfs for file generation.

use morphir_common::vfs::Vfs;
use morphir_ir::ir::attributes::{TypeAttributes, ValueAttributes};
use morphir_ir::ir::literal::Literal as MorphirLiteral;
use morphir_ir::ir::pattern::Pattern as MorphirPattern;
use morphir_ir::ir::serde_v4::deserialize_value;
use morphir_ir::ir::v4::{
    Access as MorphirAccess, AccessControlledModuleDefinition, AccessControlledTypeDefinition,
    AccessControlledValueDefinition, ModuleDefinition,
};
use morphir_ir::ir::value_expr::Value;
use morphir_ir::naming::ModuleName;
use serde::de::IntoDeserializer;
use std::io::Result;
use std::path::PathBuf;

/// Convert a kebab-case or snake-case name to PascalCase for Gleam type constructors
fn to_pascal_case(name: &str) -> String {
    name.split(['-', '_'])
        .filter(|s| !s.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(c) => c.to_uppercase().chain(chars).collect::<String>(),
                None => String::new(),
            }
        })
        .collect()
}

/// Visitor that converts Morphir IR V4 to Gleam source code
pub struct MorphirToGleamVisitor<V: Vfs> {
    vfs: V,
    output_dir: PathBuf,
    #[allow(dead_code)]
    package_name: String,
}

impl<V: Vfs> MorphirToGleamVisitor<V> {
    /// Create a new visitor
    pub fn new(vfs: V, output_dir: PathBuf, package_name: String) -> Self {
        Self {
            vfs,
            output_dir,
            package_name,
        }
    }

    /// Convert ModuleDefinition to Gleam source file
    pub fn visit_module(
        &self,
        module_path: &ModuleName,
        module: &AccessControlledModuleDefinition,
    ) -> Result<()> {
        // Convert module path to file path: "my/module" -> "my/module.gleam"
        let file_path = self.output_dir.join(format!("{}.gleam", module_path));

        // Generate module content
        let content = self.generate_module_content(module_path, &module.value)?;

        // Write to Vfs
        self.vfs.write_from_string(&file_path, &content)?;
        Ok(())
    }

    /// Generate module content as string
    fn generate_module_content(
        &self,
        _module_path: &ModuleName,
        module: &ModuleDefinition,
    ) -> Result<String> {
        let mut output = String::new();

        // Module header comment
        output.push_str("// Generated by Morphir Gleam Backend\n");
        output.push('\n');

        // Generate type definitions
        for (type_name, type_def) in &module.types {
            self.generate_type_def(&mut output, type_name, type_def)?;
            output.push('\n');
        }

        // Generate value definitions
        for (value_name, value_def) in &module.values {
            self.generate_value_def(&mut output, value_name, value_def)?;
            output.push('\n');
        }

        Ok(output)
    }

    /// Generate a type definition
    fn generate_type_def(
        &self,
        output: &mut String,
        type_name: &str,
        type_def: &AccessControlledTypeDefinition,
    ) -> Result<()> {
        use morphir_ir::ir::v4::TypeDefinition;

        // Access control
        if matches!(type_def.access, MorphirAccess::Public) {
            output.push_str("pub ");
        }

        output.push_str("type ");
        output.push_str(type_name);

        // Type parameters
        match &type_def.value {
            TypeDefinition::TypeAliasDefinition { type_params, .. } => {
                if !type_params.is_empty() {
                    output.push('(');
                    for (i, param) in type_params.iter().enumerate() {
                        if i > 0 {
                            output.push_str(", ");
                        }
                        output.push_str(&param.to_string());
                    }
                    output.push(')');
                }
            }
            TypeDefinition::CustomTypeDefinition { type_params, .. } => {
                if !type_params.is_empty() {
                    output.push('(');
                    for (i, param) in type_params.iter().enumerate() {
                        if i > 0 {
                            output.push_str(", ");
                        }
                        output.push_str(&param.to_string());
                    }
                    output.push(')');
                }
            }
        }

        output.push_str(" {\n");

        match &type_def.value {
            TypeDefinition::TypeAliasDefinition { type_expr: _, .. } => {
                // Type alias - generate type expression
                // For now, simplified - would need to convert type_expr JSON to Gleam syntax
                output.push_str("  // Type alias\n");
            }
            TypeDefinition::CustomTypeDefinition { constructors, .. } => {
                // Custom type - generate constructors (space-separated, not pipe-separated)
                for (i, constructor) in constructors.value.iter().enumerate() {
                    if i > 0 {
                        output.push(' ');
                    } else {
                        output.push_str("  ");
                    }
                    // Gleam type constructors must start with uppercase
                    output.push_str(&to_pascal_case(&constructor.name.to_string()));

                    if !constructor.args.is_empty() {
                        output.push('(');
                        for (j, arg) in constructor.args.iter().enumerate() {
                            if j > 0 {
                                output.push_str(", ");
                            }
                            // Generate proper Gleam type syntax from arg_type JSON
                            self.generate_type_expr(output, &arg.arg_type)?;
                        }
                        output.push(')');
                    }
                }
                output.push('\n');
            }
        }

        output.push_str("}\n");
        Ok(())
    }

    /// Generate a Gleam type expression from V4 JSON type
    fn generate_type_expr(&self, output: &mut String, type_json: &serde_json::Value) -> Result<()> {
        use serde_json::Value;

        match type_json {
            // Simple string type reference (compact format): "morphir/sdk:int#int" or "a" (type variable)
            Value::String(s) => {
                if s.contains(':') || s.contains('#') {
                    // FQName reference - extract the type name part
                    let type_name = s
                        .rsplit('#')
                        .next()
                        .and_then(|s| s.split(':').next())
                        .unwrap_or(s);
                    // Convert to PascalCase for Gleam
                    output.push_str(&to_pascal_case(type_name));
                } else {
                    // Simple type variable
                    output.push_str(s);
                }
            }
            // Object format: {"Reference": ...} or {"Variable": ...}
            Value::Object(obj) => {
                if let Some(reference) = obj.get("Reference") {
                    // Reference type: {"Reference": "fqname"} or {"Reference": {"fqname": "...", "args": [...]}}
                    match reference {
                        Value::String(s) => {
                            let type_name = s.rsplit('#').next().unwrap_or(s);
                            output.push_str(&to_pascal_case(type_name));
                        }
                        Value::Object(ref_obj) => {
                            if let Some(Value::String(fqname)) = ref_obj.get("fqname") {
                                let type_name = fqname.rsplit('#').next().unwrap_or(fqname);
                                output.push_str(&to_pascal_case(type_name));
                            }
                            // Handle type arguments if present
                            if let Some(Value::Array(args)) = ref_obj.get("args")
                                && !args.is_empty()
                            {
                                output.push('(');
                                for (i, arg) in args.iter().enumerate() {
                                    if i > 0 {
                                        output.push_str(", ");
                                    }
                                    self.generate_type_expr(output, arg)?;
                                }
                                output.push(')');
                            }
                        }
                        Value::Array(arr) if !arr.is_empty() => {
                            // Array format: ["fqname", arg1, arg2, ...]
                            if let Some(Value::String(fqname)) = arr.first() {
                                let type_name = fqname.rsplit('#').next().unwrap_or(fqname);
                                output.push_str(&to_pascal_case(type_name));
                                if arr.len() > 1 {
                                    output.push('(');
                                    for (i, arg) in arr.iter().skip(1).enumerate() {
                                        if i > 0 {
                                            output.push_str(", ");
                                        }
                                        self.generate_type_expr(output, arg)?;
                                    }
                                    output.push(')');
                                }
                            }
                        }
                        _ => output.push_str("Unknown"),
                    }
                } else if let Some(var) = obj.get("Variable") {
                    // Variable type: {"Variable": "a"} or {"Variable": {"name": "a"}}
                    match var {
                        Value::String(s) => output.push_str(s),
                        Value::Object(var_obj) => {
                            if let Some(Value::String(name)) = var_obj.get("name") {
                                output.push_str(name);
                            } else {
                                output.push('a');
                            }
                        }
                        _ => output.push('a'),
                    }
                } else if let Some(tuple) = obj.get("Tuple") {
                    // Tuple type: {"Tuple": [type1, type2, ...]}
                    if let Value::Array(elements) = tuple {
                        output.push_str("#(");
                        for (i, elem) in elements.iter().enumerate() {
                            if i > 0 {
                                output.push_str(", ");
                            }
                            self.generate_type_expr(output, elem)?;
                        }
                        output.push(')');
                    } else {
                        output.push_str("#()");
                    }
                } else if let Some(function) = obj.get("Function") {
                    // Function type: {"Function": {"argumentType": ..., "returnType": ...}}
                    if let Value::Object(fn_obj) = function {
                        output.push_str("fn(");
                        if let Some(arg_type) = fn_obj.get("argumentType") {
                            self.generate_type_expr(output, arg_type)?;
                        }
                        output.push_str(") -> ");
                        if let Some(return_type) = fn_obj.get("returnType") {
                            self.generate_type_expr(output, return_type)?;
                        }
                    } else {
                        output.push_str("fn() -> Nil");
                    }
                } else {
                    // Unknown type structure, use a placeholder
                    output.push('a');
                }
            }
            // Array format (compact Reference): ["fqname", arg1, arg2, ...]
            Value::Array(arr) if !arr.is_empty() => {
                if let Some(Value::String(fqname)) = arr.first() {
                    let type_name = fqname.rsplit('#').next().unwrap_or(fqname);
                    output.push_str(&to_pascal_case(type_name));
                    if arr.len() > 1 {
                        output.push('(');
                        for (i, arg) in arr.iter().skip(1).enumerate() {
                            if i > 0 {
                                output.push_str(", ");
                            }
                            self.generate_type_expr(output, arg)?;
                        }
                        output.push(')');
                    }
                }
            }
            _ => {
                // Fallback for unknown formats
                output.push('a');
            }
        }

        Ok(())
    }

    /// Generate a value definition
    fn generate_value_def(
        &self,
        output: &mut String,
        value_name: &str,
        value_def: &AccessControlledValueDefinition,
    ) -> Result<()> {
        // Access control
        if matches!(value_def.access, MorphirAccess::Public) {
            output.push_str("pub ");
        }

        output.push_str("fn ");
        output.push_str(value_name);
        output.push('(');

        // Parameters
        for (i, input) in value_def.value.input_types.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&input.0.to_string());
        }

        output.push_str(") {\n  ");

        // Body - V4 stores body as JSON, deserialize and generate Gleam code
        match &value_def.value.body {
            morphir_ir::ir::v4::ValueBody::ExpressionBody { body } => {
                // Deserialize the V4 JSON body to a typed Value
                match self.deserialize_value_body(body) {
                    Ok(value) => {
                        self.generate_value_expr(output, &value)?;
                    }
                    Err(e) => {
                        // Fallback: output as todo with error message
                        output.push_str("todo // deserialization error: ");
                        output.push_str(&e);
                    }
                }
            }
            morphir_ir::ir::v4::ValueBody::NativeBody { hint, .. } => {
                output.push_str("// native: ");
                output.push_str(&format!("{:?}", hint));
            }
            morphir_ir::ir::v4::ValueBody::ExternalBody { external_name, .. } => {
                output.push_str("// external: ");
                output.push_str(external_name);
            }
            morphir_ir::ir::v4::ValueBody::IncompleteBody { .. } => {
                output.push_str("todo // incomplete");
            }
        }

        output.push_str("\n}\n");
        Ok(())
    }

    /// Deserialize a V4 JSON body to a typed Value
    fn deserialize_value_body(
        &self,
        body: &serde_json::Value,
    ) -> std::result::Result<Value<TypeAttributes, ValueAttributes>, String> {
        let deserializer = body.clone().into_deserializer();
        deserialize_value(deserializer).map_err(|e| e.to_string())
    }

    /// Generate value expression
    fn generate_value_expr(
        &self,
        output: &mut String,
        value: &Value<TypeAttributes, ValueAttributes>,
    ) -> Result<()> {
        match value {
            Value::Literal(_, lit) => {
                self.generate_literal(output, lit)?;
            }
            Value::Variable(_, name) => {
                output.push_str(&name.to_string());
            }
            Value::Apply(_, function, argument) => {
                self.generate_value_expr(output, function)?;
                output.push('(');
                self.generate_value_expr(output, argument)?;
                output.push(')');
            }
            Value::Lambda(_, param, body) => {
                output.push_str("fn(");
                self.generate_pattern(output, param)?;
                output.push_str(") { ");
                self.generate_value_expr(output, body)?;
                output.push_str(" }");
            }
            Value::LetDefinition(_, name, def, body) => {
                // Gleam uses: let name = value \n body (no 'in' keyword)
                output.push_str("let ");
                output.push_str(&name.to_string());
                output.push_str(" = ");
                self.generate_value_expr(output, def.body.get_expression()?)?;
                output.push_str("\n  ");
                self.generate_value_expr(output, body)?;
            }
            Value::IfThenElse(_, condition, then_branch, else_branch) => {
                // Gleam supports case for boolean pattern matching
                output.push_str("case ");
                self.generate_value_expr(output, condition)?;
                output.push_str(" { True -> ");
                self.generate_value_expr(output, then_branch)?;
                output.push_str(", False -> ");
                self.generate_value_expr(output, else_branch)?;
                output.push_str(" }");
            }
            Value::Record(_, fields) => {
                output.push_str("{ ");
                for (i, field) in fields.iter().enumerate() {
                    if i > 0 {
                        output.push_str(", ");
                    }
                    output.push_str(&field.0.to_string());
                    output.push_str(": ");
                    self.generate_value_expr(output, &field.1)?;
                }
                output.push_str(" }");
            }
            Value::Field(_, record, field) => {
                self.generate_value_expr(output, record)?;
                output.push('.');
                output.push_str(&field.to_string());
            }
            Value::Tuple(_, elements) => {
                output.push_str("#(");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        output.push_str(", ");
                    }
                    self.generate_value_expr(output, elem)?;
                }
                output.push(')');
            }
            Value::PatternMatch(_, subject, cases) => {
                output.push_str("case ");
                self.generate_value_expr(output, subject)?;
                output.push_str(" { ");
                for (i, case) in cases.iter().enumerate() {
                    if i > 0 {
                        output.push(' ');
                    }
                    self.generate_pattern(output, &case.0)?;
                    output.push_str(" -> ");
                    self.generate_value_expr(output, &case.1)?;
                }
                output.push_str(" }");
            }
            Value::Constructor(_, fqname) => {
                output.push_str(&fqname.local_name.to_string());
            }
            Value::Reference(_, fqname) => {
                // For references, output just the local name for now
                output.push_str(&fqname.local_name.to_string());
            }
            Value::List(_, items) => {
                output.push('[');
                for (i, item) in items.iter().enumerate() {
                    if i > 0 {
                        output.push_str(", ");
                    }
                    self.generate_value_expr(output, item)?;
                }
                output.push(']');
            }
            Value::Unit(_) => {
                output.push_str("Nil");
            }
            _ => {
                output.push_str("todo");
            }
        }
        Ok(())
    }

    /// Generate pattern
    fn generate_pattern(
        &self,
        output: &mut String,
        pattern: &MorphirPattern<ValueAttributes>,
    ) -> Result<()> {
        match pattern {
            MorphirPattern::WildcardPattern(_) => {
                output.push('_');
            }
            MorphirPattern::AsPattern(_, sub_pattern, name) => {
                // In Gleam, `x as name` is often just a binding
                // If sub_pattern is wildcard, just output the name
                if matches!(**sub_pattern, MorphirPattern::WildcardPattern(_)) {
                    output.push_str(&name.to_string());
                } else {
                    self.generate_pattern(output, sub_pattern)?;
                    output.push_str(" as ");
                    output.push_str(&name.to_string());
                }
            }
            MorphirPattern::TuplePattern(_, elements) => {
                output.push_str("#(");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        output.push_str(", ");
                    }
                    self.generate_pattern(output, elem)?;
                }
                output.push(')');
            }
            MorphirPattern::ConstructorPattern(_, fqname, args) => {
                output.push_str(&fqname.local_name.to_string());
                if !args.is_empty() {
                    output.push('(');
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 {
                            output.push_str(", ");
                        }
                        self.generate_pattern(output, arg)?;
                    }
                    output.push(')');
                }
            }
            MorphirPattern::LiteralPattern(_, lit) => {
                self.generate_literal(output, lit)?;
            }
            MorphirPattern::UnitPattern(_) => {
                output.push_str("Nil");
            }
            MorphirPattern::HeadTailPattern(_, head, tail) => {
                // Gleam list pattern: [head, ..tail]
                output.push('[');
                self.generate_pattern(output, head)?;
                output.push_str(", ..");
                self.generate_pattern(output, tail)?;
                output.push(']');
            }
            MorphirPattern::EmptyListPattern(_) => {
                output.push_str("[]");
            }
        }
        Ok(())
    }

    /// Generate literal
    fn generate_literal(&self, output: &mut String, lit: &MorphirLiteral) -> Result<()> {
        match lit {
            MorphirLiteral::Bool(b) => {
                output.push_str(if *b { "True" } else { "False" });
            }
            MorphirLiteral::Integer(i) => {
                output.push_str(&i.to_string());
            }
            MorphirLiteral::Float(f) => {
                output.push_str(&f.to_string());
            }
            MorphirLiteral::String(s) => {
                output.push('"');
                output.push_str(s);
                output.push('"');
            }
            MorphirLiteral::Char(c) => {
                output.push('\'');
                output.push(*c);
                output.push('\'');
            }
            MorphirLiteral::Decimal(d) => {
                output.push_str(d);
            }
        }
        Ok(())
    }
}

/// Helper trait for ValueBody to extract the expression
trait ValueBodyExt {
    fn get_expression(&self) -> Result<&Value<TypeAttributes, ValueAttributes>>;
}

impl ValueBodyExt for morphir_ir::ir::value_expr::ValueBody<TypeAttributes, ValueAttributes> {
    fn get_expression(&self) -> Result<&Value<TypeAttributes, ValueAttributes>> {
        match self {
            morphir_ir::ir::value_expr::ValueBody::Expression(expr) => Ok(expr),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Expected expression body",
            )),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use indexmap::IndexMap;
    use morphir_common::vfs::MemoryVfs;
    use morphir_ir::ir::v4::Access as MorphirAccess;
    use morphir_ir::ir::v4::{AccessControlledModuleDefinition, ModuleDefinition};
    use morphir_ir::naming::ModuleName;
    use std::path::PathBuf;

    #[test]
    fn test_generate_module() {
        let vfs = MemoryVfs::new();
        let output_dir = PathBuf::from("/test");
        let package_name = "test-package".to_string();
        let visitor = MorphirToGleamVisitor::new(vfs, output_dir, package_name);

        let module_name = ModuleName::parse("test_module");
        let module_def = AccessControlledModuleDefinition {
            access: MorphirAccess::Public,
            value: ModuleDefinition {
                types: IndexMap::new(),
                values: IndexMap::new(),
                doc: None,
            },
        };

        // Test that visitor can generate module
        let result = visitor.visit_module(&module_name, &module_def);
        assert!(result.is_ok());
    }

    #[test]
    fn test_generate_literal() {
        let vfs = MemoryVfs::new();
        let visitor = MorphirToGleamVisitor::new(vfs, PathBuf::from("/test"), "test".to_string());

        let mut output = String::new();
        let lit = MorphirLiteral::Bool(true);
        visitor.generate_literal(&mut output, &lit).unwrap();
        assert_eq!(output, "True");

        output.clear();
        let lit = MorphirLiteral::Integer(42);
        visitor.generate_literal(&mut output, &lit).unwrap();
        assert_eq!(output, "42");

        output.clear();
        let lit = MorphirLiteral::String("hello".to_string());
        visitor.generate_literal(&mut output, &lit).unwrap();
        assert_eq!(output, "\"hello\"");
    }
}
