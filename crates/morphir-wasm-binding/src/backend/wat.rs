//! WAT (WebAssembly Text) generation from Morphir IR

use morphir_extension_sdk::prelude::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt::Write;

/// Morphir distribution IR (simplified)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Distribution {
    #[serde(default)]
    pub name: String,
    #[serde(default)]
    pub modules: Vec<ModuleIR>,
}

/// Module IR representation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleIR {
    pub name: String,
    #[serde(default)]
    pub values: Vec<ValueDef>,
}

/// Value definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValueDef {
    pub name: String,
    #[serde(default)]
    pub body: serde_json::Value,
}

/// Generate WAT (WebAssembly Text) from Morphir IR
pub fn generate_wat(
    ir: &serde_json::Value,
    options: &HashMap<String, serde_json::Value>,
) -> Result<Vec<Artifact>> {
    let mut artifacts = Vec::new();

    // Try to parse as distribution or module list
    let (name, modules): (String, Vec<ModuleIR>) =
        if let Ok(dist) = serde_json::from_value::<Distribution>(ir.clone()) {
            (dist.name, dist.modules)
        } else if let Ok(modules) = serde_json::from_value::<Vec<ModuleIR>>(ir.clone()) {
            ("morphir".to_string(), modules)
        } else {
            // Try single module
            let module = serde_json::from_value::<ModuleIR>(ir.clone())?;
            (module.name.clone(), vec![module])
        };

    let pretty = options
        .get("format")
        .and_then(|v| v.as_str())
        .map(|s| s == "pretty")
        .unwrap_or(true);

    let wat = compile_to_wat(&name, &modules, pretty);

    artifacts.push(Artifact {
        path: format!("{}.wat", name),
        content: wat,
        binary: false,
    });

    Ok(artifacts)
}

/// Compile Morphir modules to WAT text format
fn compile_to_wat(name: &str, modules: &[ModuleIR], pretty: bool) -> String {
    let mut output = String::new();
    let indent = if pretty { "  " } else { "" };

    // String's Write impl never fails, so unwrap is safe
    let _ = writeln!(output, "(module");
    let _ = writeln!(output, "{};;  Generated by Morphir WASM Backend", indent);
    let _ = writeln!(output, "{};;  Module: {}", indent, name);
    let _ = writeln!(output);

    // Generate functions for each value definition
    for module_ir in modules {
        for value_def in &module_ir.values {
            let func_name = format!("{}_{}", module_ir.name, value_def.name);

            let _ = write!(output, "{}(func ${}", indent, func_name);
            let _ = writeln!(output, " (export \"{}\") (result i32)", func_name);

            // Generate function body
            generate_wat_body(
                &mut output,
                &value_def.body,
                &format!("{}{}", indent, indent),
            );

            let _ = writeln!(output, "{})", indent);
            let _ = writeln!(output);
        }
    }

    let _ = writeln!(output, ")");

    output
}

/// Generate WAT instructions for a Morphir expression
fn generate_wat_body(output: &mut String, body: &serde_json::Value, indent: &str) {
    if let Some(obj) = body.as_object()
        && let Some(kind) = obj.get("kind").and_then(|v| v.as_str())
    {
        match kind {
            "literal" => {
                if let Some(value) = obj.get("value")
                    && let Some(lit_obj) = value.as_object()
                    && let Some(lit_type) = lit_obj.get("type").and_then(|v| v.as_str())
                {
                    match lit_type {
                        "int" => {
                            if let Some(n) = lit_obj.get("value").and_then(|v| v.as_i64()) {
                                let _ = writeln!(output, "{}(i32.const {})", indent, n);
                                return;
                            }
                        }
                        "bool" => {
                            if let Some(b) = lit_obj.get("value").and_then(|v| v.as_bool()) {
                                let _ = writeln!(
                                    output,
                                    "{}(i32.const {})",
                                    indent,
                                    if b { 1 } else { 0 }
                                );
                                return;
                            }
                        }
                        _ => {
                            let _ = writeln!(
                                output,
                                "{};;  Unsupported literal type: {}",
                                indent, lit_type
                            );
                        }
                    }
                }
            }
            "apply" => {
                let _ = writeln!(output, "{};;  Function application", indent);
            }
            "lambda" => {
                let _ = writeln!(output, "{};;  Lambda expression", indent);
            }
            _ => {
                let _ = writeln!(output, "{};;  Expression kind: {}", indent, kind);
            }
        }
    }

    // Default: return 0
    let _ = writeln!(output, "{}(i32.const 0)", indent);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_wat() {
        let ir = serde_json::json!({
            "name": "example",
            "modules": [{
                "name": "main",
                "values": [{
                    "name": "answer",
                    "body": {
                        "kind": "literal",
                        "value": {
                            "type": "int",
                            "value": 42
                        }
                    }
                }]
            }]
        });

        let options = HashMap::new();
        let result = generate_wat(&ir, &options).unwrap();

        assert_eq!(result.len(), 1);
        assert!(result[0].path.ends_with(".wat"));
        assert!(!result[0].binary);
        assert!(result[0].content.contains("(module"));
        assert!(result[0].content.contains("(i32.const 42)"));
    }
}
